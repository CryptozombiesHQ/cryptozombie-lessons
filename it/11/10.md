---
title: Trasferimento di token ERC721 - Scenario in due fasi
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            xcontext("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    // start here
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                    // TODO: Test the two-step scenario.  The owner calls transferFrom
                 })
            })
        })
      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
              })
              xit("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                  // TODO: Test the two-step scenario.  The owner calls transferFrom
               })
          })
      })
---

Ora, utilizzare "approve" seguito da "transferFrom" per trasferire i token ERC721 è tutt'altro che una passeggiata, ma siamo qui per imparare.

In poche parole, dobbiamo testare due diversi scenari:

- Alice autorizza Bob a prendere il token ERC721. Quindi, Bob (l'**indirizzo approvato**) chiama "transferFrom".

- Alice autorizza Bob a prendere il token ERC721. Successivamente, Alice trasferisce il token ERC721.

La differenza nei due scenari sta su _**chi**_ chiama il trasferimento effettivo, Alice o Bob.

L'abbiamo fatto sembrare semplice, giusto?

Diamo un'occhiata al primo scenario.

## Bob chiama transferFrom

I passaggi per questo scenario sono i seguenti:

- Alice crea un nuovo token ERC721 e quindi chiama "approve".
- Successivamente, Bob esegue "transferFrom" che dovrebbe renderlo il proprietario del token EC721.
- Infine, dobbiamo chiamare `assert.equal` con `newOwner` e `bob` come parametri.

# Testiamo

1. Le prime due righe di codice del nostro test sono simili al test precedente. Siamo andati avanti e li abbiamo copiati e incollati per te.

2. Quindi, per far approvare a Bob il token ERC721, chiama `approve()`. La funzione accetta `bob` e `zombieId` come parametri. Inoltre, assicurati che Alice chiami il metodo (poiché è il suo token ERC721 che verrà trasferito).

3. Le ultime tre righe di codice sono **quasi simili** al test precedente. Ancora una volta, siamo andati avanti e li abbiamo copiati e incollati per te. Aggiorniamo la chiamata alla funzione `transferFrom()` in modo che il mittente sia Bob.

4. Infine, "abilitiamo" questo scenario e "saltamo" l'ultimo test case, quello che dobbiamo ancora codificare.

È ora di eseguire il `test di Truffle` e vedere se è tutto corretto:

```bash
Contract: CryptoZombies
    ✓ should be able to create a new zombie (218ms)
    ✓ should not allow two zombies (175ms)
    with the single-step transfer scenario
      ✓ should transfer a zombie (334ms)
    with the two-step transfer scenario
      ✓ should approve and then transfer a zombie when the owner calls transferFrom (360ms)
      - should approve and then transfer a zombie when the approved address calls transferFrom


  4 passing (2s)
  1 pending
```

Fantastico! Adesso andiamo al prossimo test.
