---
title: Trasferire Zombie
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })

            // start here
        })
      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };
    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
          xcontext("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                // TODO: Test the single-step transfer scenario.
              })
          })
          xcontext("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                // TODO: Test the two-step scenario.  The approved address calls transferFrom
              })
              it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                  // TODO: Test the two-step scenario.  The owner calls transferFrom
               })
          })
      })
---

Domanda- Diciamo che Alice voglia inviare uno dei suoi zombie a Bob. Dovremmo testarlo?

Sicuramente!

Se hai seguito le lezioni precedenti, dovresti sapere che, tra le altre cose, i nostri zombi ereditano da _ERC721_. E la specifica _ERC721_ ha 2 modi diversi per trasferire i token:

**(1)**

```sol
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

Il primo modo prevede che _Alice_ (la proprietaria) chiami `transferFrom` con il suo `indirizzo` come parametro `_from`, l'`indirizzo` di Bob come parametro `_to` e lo `zombieId` che vuole trasferire.

**(2)**

```sol
function approve(address _approved, uint256 _tokenId) external payable;
```

seguito da

```sol
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

Il secondo modo prevede che Alice prima chiami "approve" con l'indirizzo di Bob e "zombieId". Il contratto quindi memorizza che Bob Ã¨ autorizzato a prendere lo zombi. Successivamente, quando Alice o Bob chiama "transferFrom", il contratto controlla se quel "msg.sender" Ã¨ uguale all'indirizzo di Alice o Bob. In tal caso, trasferisce lo zombi a Bob.

Chiameremo questi due modi di trasferire gli zombi "scenari". Per testare ogni scenario, creeremo due diversi gruppi di test e forniremo loro delle descrizioni significative.

PerchÃ© raggrupparli? Abbiamo solo pochi test...

SÃ¬, in questo momento la nostra logica Ã¨ piuttosto semplice, ma potrebbe non essere sempre cosÃ¬. Tuttavia, il secondo scenario (che Ã¨ "approve" seguito da "transferFrom") richiede almeno due test:

- per prima cosa, dobbiamo verificare se Alice stessa Ã¨ in grado di trasferire lo zombi.

- secondo, dobbiamo controllare se Bob puÃ² eseguire `transferFrom`.

Inoltre, in futuro, potresti voler aggiungere altre funzionalitÃ  che richiederebbero test diversi. Riteniamo che sia meglio mettere in atto una struttura scalabile fin dall'inizioðŸ˜‰. Rende la comprensione del tuo codice molto piÃ¹ semplice per gli estranei o per te stesso se hai passato del tempo a concentrarti su qualcos'altro per un po' di tempo.

> Nota: se ti trovi in â€‹â€‹una posizione in cui lavori con altri programmatori, scoprirai che Ã¨ piÃ¹ probabile che seguano le convenzioni che hai stabilito nel codice iniziale. Essere in grado di collaborare in modo efficace Ã¨ una delle competenze chiave di cui avrai bisogno se vuoi lavorare su progetti grandi e di successo. Ottenere buone abitudini che ti aiutino a farlo il prima possibile renderÃ  la tua vita di programmatore piÃ¹ facile e di maggior successo.

## La funzione 'context'

Per raggruppare i test, _Truffle_ fornisce una funzione chiamata `context`. Lascia che ti mostri rapidamente come usarlo per strutturare meglio il nostro codice:

```javascript
context('with the single-step transfer scenario', async () => {
	it('should transfer a zombie', async () => {
		// TODO: Test the single-step transfer scenario.
	});
});

context('with the two-step transfer scenario', async () => {
	it('should approve and then transfer a zombie when the approved address calls transferFrom', async () => {
		// TODO: Test the two-step scenario.  The approved address calls transferFrom
	});
	it('should approve and then transfer a zombie when the owner calls transferFrom', async () => {
		// TODO: Test the two-step scenario.  The owner calls transferFrom
	});
});
```

Se lo aggiungiamo al nostro file `CryptoZombies.js` e quindi eseguiamo `truffle test` l'output sarÃ  simile a questo:

```bash
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (100ms)
    âœ“ should not allow two zombies (251ms)
    with the single-step transfer scenario
      âœ“ should transfer a zombie
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the owner calls transferFrom
      âœ“ should approve and then transfer a zombie when the approved address calls transferFrom


  5 passing (2s)
```

Bene?

Hmm...

Dai un'occhiata di nuovo: c'Ã¨ un problema con l'output sopra. Sembra che tutti i test siano passati, il che ovviamente Ã¨ falso dato che non li abbiamo nemmeno scritti!!

Fortunatamente, c'Ã¨ una soluzione semplice: se mettiamo una `x` davanti alle funzioni `context()` come segue: `xcontext()`, `Truffle` salterÃ  quei test.

> Nota: `x` puÃ² essere posizionato anche prima di una funzione `it()`. Non dimenticare di rimuovere tutte le x quando i test sono pronti!

Ora, eseguiamo il `test di Turfle`. L'output dovrebbe assomigliare a questo:

```
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (199ms)
    âœ“ should not allow two zombies (175ms)
    with the single-step transfer scenario
      - should transfer a zombie
    with the two-step transfer scenario
      - should approve and then transfer a zombie when the owner calls transferFrom
      - should approve and then transfer a zombie when the approved address calls transferFrom


  2 passing (827ms)
  3 pending
```

Dove "-" che Ã¨ stato saltato tramite l'utilizzo della "x" all'inizio del test.

Abbastanza pulito, eh? Ora puoi eseguire i tuoi test mentre procedi e contrassegnare le funzioni vuote in cui sai che dovrai scrivere i test prossimamente.

# Testiamo

1. Vai avanti e copia/incolla il codice in alto.

2. Per adesso, _saltiamo_ le nostre nuove funzioni `context`.

I nostri test sono vuoti e c'Ã¨ molta logica da scrivere per implementarli. Lo faremo in pezzi piÃ¹ piccoli nei prossimi capitoli.
