---
title: Introduzione (continua)
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
    risposta: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      contract("CryptoZombies", (accounts) => {
          it("should be able to create a new zombie", () => {

          })
      })
---

Andiamo avanti. in questo capitolo continuiamo con le impostazioni per scrivere e lanciare i nostri test.

## Build Artifacts

Ogni volta che si compila uno smart contract, il compilatore _Solidity_ genera un file JSON (denominato **build artefacts**) che contiene la rappresentazione binaria di quel contratto e lo salva nella cartella `build/contracts`.

Successivamente, quando esegui una migrazione, _Truffle_ aggiorna questo file con le informazioni relative a quella rete.

La prima cosa che devi fare ogni volta che inizi a scrivere una nuova suite di test √® caricare gli artifacts di build del contratto con cui vuoi interagire. In questo modo, **Truffle** sapr√† come formattare le nostre chiamate di funzione in un modo comprensibile per il contratto.

Vediamo subito un semplice esempio.

Supponiamo che esistesse un contratto chiamato "MyAwesomeContract". Potremmo fare qualcosa del genere per caricare gli artifacts della build:

```javascript
const MyAwesomeContract = artifacts.require(‚ÄúMyAwesomeContract‚Äù);
```

The function returns something called a **_contract abstraction_**. In a nutshell, a _contract abstraction_ hides the complexity of interacting with **Ethereum** and provides a convenient _JavaScript_ interface to our _Solidity_ smart contract. We'll be using it in the next chapters.

La funzione restituisce qualcosa chiamato **_contract abstraction_**. In poche parole, una \__contract abstraction_ nasconde la complessit√† dell'interazione con **Ethereum** e fornisce una comoda interfaccia _JavaScript_ per il nostro smart contract in _Solidity_. Lo useremo nei prossimi capitoli.

### La funzione contract()

**Truffle** aggiunge un sottile involucro intorno alla **Mocha** per semplificare i test. Poich√© il nostro corso si concentra sullo sviluppo di **Ethereum**, non entreremo nel troppo dettaglio su _Mocha_. Se vuoi saperne di pi√π riguardo _Mocha_, vai sul <a href="https://mochajs.org/" target=_blank>loro sito ufficiale</a> una volta che avrai terminato questa lezione. Per adesso devi solo capire cosa impararemo qui - Come fare:

- **Test di gruppo** utilizzando la funzione `contract()`. Questa funzione estende la funzione `describe()` di **Mocha** fornendo una **lista di account per i test** e mantendo un po' di pulizia.

  `contract()` prende due argomenti. Il primo, una `string`, deve indicare cosa testeremo. Il secondo parametro, un `callback`, √® dove scriveremo effettivamente i nostri test.

- **Eseguimaoli**: il modo in cui lo faremo √® chiamare una funzione chiamata `it()` che accetta anche due argomenti: una `string` che descrive cosa fa effettivamente il test e un `callback`.

Mettendolo tutto questo insieme, ecco un semplice test:

```javascript
contract('MyAwesomeContract', (accounts) => {
	it('should be able to receive Ethers', () => {});
});
```

> Nota: un test scritto bene spiega cosa fa effettivamente il codice. Assicurati che la descrizione della suite di test e il test case possano essere letti insieme come una **affermazione coerente**. Pensa come se stessi scrivendo della documentazione relativa al tuo codice.

Ogni test che scriverai dovr√† seguire questo schema. Sembra facile, non √® vero?üòÅ

# Mettiti alla prova

Ora che abbiamo creato un file `CryptoZombies.js` vuoto, √® il momento di riempirlo.

1. La prima riga di codice dovrebbe dichiarare un `const` chiamato `CryptoZombies` e impostarlo uguale al risultato della funzione `artifacts.require` con il nome del contratto che vogliamo testare come argomento.

2. Quindi, vai avanti e copia/incolla il test qui in alto.
3. Cambia il modo in cui chiamiamo `contract()` in modo tale che il primo parametro sia il nome del nostro smart contract.

   > Nota: non preoccuparti dell'argomento `accounts`. Lo spiegheremo nel prossimo capitolo.

4. Il primo parametro passato alla funzione `it()` (nel nostro esempio, cio√® "should be able to receive Ether") dovrebbe essere il nome del nostro test. Dal momento che il nostro scopo √® scrivere un test per la creazione di un nuovo zombi, assicurati che il primo parametro sia impostato su "should be able to create a new zombie".

Abbiamo impostato la base. Andiamo al prossimo capitolo!
