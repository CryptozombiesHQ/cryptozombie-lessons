---
title: Attacchi Zombie
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const time = require("./helpers/time");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            context("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner,bob);
                 })
            })
            it("zombies should be able to attack another zombie", async () => {
                let result;
                result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                const firstZombieId = result.logs[0].args.zombieId.toNumber();
                result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
                const secondZombieId = result.logs[0].args.zombieId.toNumber();
                //TODO: increase the time
                await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
                assert.equal(result.receipt.status, true);
            })
        })
      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };

      'test/helpers/time.js': |
        async function increase(duration) {

            //first, let's increase time
            await web3.currentProvider.sendAsync({
                jsonrpc: "2.0",
                method: "evm_increaseTime",
                params: [duration], // there are 86400 seconds in a day
                id: new Date().getTime()
            }, () => {});

            //next, let's mine a new block
            web3.currentProvider.send({
                jsonrpc: '2.0',
                method: 'evm_mine',
                params: [],
                id: new Date().getTime()
            })

        }

        const duration = {

            seconds: function (val) {
                return val;
            },
            minutes: function (val) {
                return val * this.seconds(60);
            },
            hours: function (val) {
                return val * this.minutes(60);
            },
            days: function (val) {
                return val * this.hours(24);
            },
        }

        module.exports = {
            increase,
            duration,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const time = require("./helpers/time");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
              })
              it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner,bob);
               })
          })
          it("zombies should be able to attack another zombie", async () => {
              let result;
              result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              const firstZombieId = result.logs[0].args.zombieId.toNumber();
              result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
              const secondZombieId = result.logs[0].args.zombieId.toNumber();
              await time.increase(time.duration.days(1));
              await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
              assert.equal(result.receipt.status, true);
          })
      })
---

Wow! Con i capitoli precedenti abbiamo ricoperto una vastità di argomenti.

Quindi abbiamo finito ora con tutti gli scenari? No, non ci siamo ancora; abbiamo lasciato le cose migliori per la fine.

Abbiamo creato un gioco di zombi e **la parte migliore** è far combattere gli zombie, giusto?

Questo test è piuttosto semplice e consiste nei seguenti passaggi:

- **Primo**, creeremo due nuovi zombi: uno per Alice e l'altro per Bob.
- **Secondo**, Alice eseguirà l'azione di attacco "attack" sullo zombie di Bob, specificando lo "zombieId" come parametro
- **Infine**, affinché il test venga superato con successo, verificheremo se `result.receipt.status` è uguale a `true`

Mentre siamo qui, ho codificato rapidamente tutta questa logica e l'ho inserita in una funzione `it()` ed eseguito `truffle test`.

L'output sarebbe simile a questo:

```bash
Contract: CryptoZombies
    ✓ should be able to create a new zombie (102ms)
    ✓ should not allow two zombies (321ms)
    ✓ should return the correct owner (333ms)
    1) zombies should be able to attack another zombie
    with the single-step transfer scenario
      ✓ should transfer a zombie (307ms)
    with the two-step transfer scenario
      ✓ should approve and then transfer a zombie when the approved address calls transferFrom (357ms)


  5 passing (7s)
  1 failing

  1) Contract: CryptoZombies
       zombies should be able to attack another zombie:
     Error: Returned error: VM Exception while processing transaction: revert

```

Uh oh. Il nostro test è fallito☹️.

Ma perché?

Scopriamolo. Per prima cosa, daremo un'occhiata più da vicino al codice all'interno della funzione `createRandomZombie()`:

```sol
function createRandomZombie(string _name) public {
  require(ownerZombieCount[msg.sender] == 0);
  uint randDna = _generateRandomDna(_name);
  randDna = randDna - randDna % 100;
  _createZombie(_name, randDna);
}
```

Fin qui tutto bene. Andando avanti, analizziamo `_createZombie()`:

```sol
function _createZombie(string _name, uint _dna) internal {
  uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
  zombieToOwner[id] = msg.sender;
  ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);
  emit NewZombie(id, _name, _dna);
}
```

Ohh, hai notato il problema?

Il nostro test è fallito perché abbiamo aggiunto un periodo di **cooldown** al nostro gioco e fatto in modo che gli zombi debbano attendere **1 giorno** dopo aver attaccato (o nutrito) prima di effettuare un'altra azione.

Senza questo, lo zombi potrebbe attaccare e moltiplicarsi innumerevoli volte al giorno, il che renderebbe il gioco troppo facile.

Ora, cosa dobbiamo fare adesso... aspettare un giorno?

## Viaggio nel tempo

Fortunatamente, non dobbiamo aspettare così tanto. In effetti, non c'è bisogno di aspettare affatto. Questo perché _Ganache_ fornisce un modo per andare avanti nel tempo attraverso due funzioni di supporto:

- `evm_increaseTime`: aumenta il tempo per il blocco successivo.
- `evm_mine`: estrae un nuovo blocco.

Non hai nemmeno bisogno di un Tardis o di una DeLorean per questo tipo di viaggio nel tempo.

Lascia che ti spieghi come funzionano queste funzioni:

- Ogni volta che un nuovo blocco viene estratto, il minatore aggiunge un timestamp. Diciamo che le transazioni che hanno creato i nostri zombi sono state estratte nel blocco 5.

- Successivamente, chiamiamo `evm_increaseTime` ma, poiché la blockchain è immutabile, non c'è modo di modificare un blocco esistente. Quindi, quando il contratto verificherà il tempo, questo non verrà aumentato.

- Se eseguiamo `evm_mine`, il blocco numero 6 viene estratto (e timestamp) il che significa che, quando mettiamo gli zombi a combattere, lo smart contract "vedrà" che è trascorso un giorno.
- Mettiamo tutto insieme così possiamo risolvere il nostro test viaggiando nel tempo:

```javascript
await web3.currentProvider.sendAsync(
	{
		jsonrpc: '2.0',
		method: 'evm_increaseTime',
		params: [86400], // there are 86400 seconds in a day
		id: new Date().getTime(),
	},
	() => {}
);

web3.currentProvider.send({
	jsonrpc: '2.0',
	method: 'evm_mine',
	params: [],
	id: new Date().getTime(),
});
```

Sì, è un bel pezzo di codice, ma non vorremmo aggiungere questa logica al nostro file `CryptoZombies.js`.

Siamo andati avanti e abbiamo spostato tutto in un nuovo file chiamato `helpers/time.js`. Per aumentare il tempo, dovrai semplicemente chiamare: `time.increaseTime(86400);`

Sì, non è ancora abbastanza. Dopotutto, ci aspettiamo davvero che tu sappia quanti secondi ci sono in un giorno ogni volta che devi chiamare questa funzione?

Ovviamente no. Questo è il motivo per cui abbiamo aggiunto un'altra _helper function_ denominata `days` che richiede il numero di giorni con cui vogliamo aumentare il tempo come argomento. Chiameresti questa funzione in questo modo: `await time.increase(time.duration.days(1))`

> Nota: ovviamente, il viaggio nel tempo non è disponibile sulla rete principale o su nessuna delle catene di test disponibili che sono protette dai minatori. Sarebbe un vero disastro se qualcuno potesse semplicemente scegliere di cambiare il modo in cui il tempo opera nel mondo reale! Per testare i contratti intelligenti, il viaggio nel tempo può essere una parte essenziale ara gli strumenti del programmatore.

# Testiamo

Siamo andati avanti e abbiamo compilato la versione del test che fallisce.

1. Scorri verso il basso fino al commento che abbiamo lasciato per te. Quindi, correggi il test case eseguendo "await time.increase" come mostrato sopra.

E' tutto pronto. Lanciamo il comando `truffle test`:

```
Contract: CryptoZombies
    ✓ should be able to create a new zombie (119ms)
    ✓ should not allow two zombies (112ms)
    ✓ should return the correct owner (109ms)
    ✓ zombies should be able to attack another zombie (475ms)
    with the single-step transfer scenario
      ✓ should transfer a zombie (235ms)
    with the two-step transfer scenario
      ✓ should approve and then transfer a zombie when the owner calls transferFrom (181ms)
      ✓ should approve and then transfer a zombie when the approved address calls transferFrom (152ms)
```

Ed ecco qua! Questo è il passaggio finale di questo capitolo.
