---
title: Manteniamo il gioco divertente (continua)
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                // start here
            })
        })
      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
          try {
              await promise;
             assert(true);
          }
          catch (err) {
              return;
          }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
          shouldThrow,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
      })
---

In questo capitolo andremo a riempire il corpo nel nostro secondo test. Il secondo test dovrebbe eseguire i seguenti passaggi:

- Primo, Alice dovrebbe chiamare `createRandomZombie` e impostare`zombieNames[0]`come nome del primo zombie.
- Successivamente, Alice dovrebbe provare a creare il suo secondo zombi. L'unica cosa diversa è che questa volta il nome dello zombi dovrebbe essere impostato su `zombieNames[1]`.
- A questo punto, ci aspettiamo che il contratto 'generi' un errore.
- Poiché il nostro test dovrebbe essere superato solo se lo smart contract si interrompe, la nostra logica apparirà leggermente diversa. Dovremo racchiudere la seconda chiamata alla funzione `createRandomZombie` all'interno di un blocco `try/catch` come segue:

```javascript
try {
	//try to create the second zombie
	await contractInstance.createRandomZombie(zombieNames[1], { from: alice });
	assert(true);
} catch (err) {
	return;
}
assert(false, 'The contract did not throw.');
```

Ora abbiamo esattamente quello che volevamo, giusto?

Hmmm... siamo abbastanza vicini.
Per mantenere i nostri test belli e ordinati, abbiamo spostato il codice sopra in `helpers/utils.js` e lo abbiamo importato in "CryptoZombies.js" in questo modo:

```javascript
const utils = require('./helpers/utils');
```

Ed ecco come dovrebbe apparire la riga di codice che chiama la funzione:

```javascript
await utils.shouldThrow(myAwesomeContractInstance.myAwesomeFunction());
```

# Testiamo

Nel capitolo precedente, abbiamo creato una funzione vuota per il nostro secondo test. Completiamola.

1.  Per prima cosa, facciamo in modo che Alice crei il suo primo zombi. Dagli `zombieNames[0]` come nome e non dimenticare di impostare correttamente il proprietario.

2.  Dopo che Alice ha creato il suo primo zombie, esegui `shouldThrow` con `createRandomZombie` come parametro. Se non ricordi la sintassi per farlo, controlla l'esempio sopra. Ma prima, prova a farlo senza sbirciare.
3.  Fantastico, hai appena finito di scrivere il tuo secondo test!

Ora, siamo andati avanti e abbiamo eseguito il `test di Truffle` per te. Ecco l'output:

```bash
Contract: CryptoZombies
    ✓ should be able to create a new zombie (129ms)
    ✓ should not allow two zombies (148ms)


  2 passing (1s)
```

Il test è passato. Hooray!
