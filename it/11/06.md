---
title: Manteniamo il gioco divertente
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;

            // start here

            it("should be able to create a new zombie", async () => {
                const contractInstance = await CryptoZombies.new();
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })

            //define the new it() function
        })

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
          })
      })
---

Ottimo lavoro! Ora sappiamo per certo che i nostri utenti possono creare nuovi zombiğŸ‘ŒğŸ».

Tuttavia, se potessero continuare a chiamare questa funzione per creare zombi illimitati nel loro esercito, il gioco non sarebbe molto divertente. Pertanto, nel <a href="https://cryptozombies.io/en/lesson/2/chapter/4" target=_blank>Capitolo 4 della lezione 2</a> abbiamo aggiunto un'istruzione `require` al `createZombieFunction()` che assicura che ogni utente non possa possedere piÃ¹ di uno zombi:

```sol
require(ownerZombieCount[msg.sender] == 0)
```

Proviamo questa funzione e vediamo se funziona.

## Hooks

In pochi minutiğŸ¤, avremo piÃ¹ di un test e ognuno dovrebbe iniziare in modo pulito. Pertanto, per ogni singolo test dovremo creare una nuova istanza del nostro smart contract nel seguente questo modo:

```javascript
const contractInstance = await CryptoZombies.new();
```

Non sarebbe bello se potessi scriverlo solo una volta e fare in modo che _Truffle_ lo esegua automaticamente per ogni test?

Bene... una delle caratteristiche di _Mocha_ (e _Truffle_) Ã¨ la possibilitÃ  di eseguire alcuni frammenti di codice chiamati _hooks_ prima o dopo un test. Per eseguire qualcosa prima che un test venga eseguito, il codice dovrebbe essere inserito in una funzione denominata `beforeEach()`.

Quindi, invece di scrivere `contract.new()` piÃ¹ volte, puoi farlo solo una volta in questo modo:

```javascript
beforeEach(async () => {
	// let's put here the code that creates a new contract instance
});
```

Poi, `Truffle` si occuperÃ  di tutto. CosÃ¬ Ã¨ tutto piÃ¹ semplice, vero?

# Testiamo

1. Sotto la riga di codice che inizializza `alice` e `bob`, dichiariamo una variabile denominata `contractInstance`. Per adesso non assegnarlo a nulla.

   > Nota: vogliamo che l'ambito di `contractInstance` sia limitato al blocco in cui Ã¨ definito. Usa `let` invece di `var`.

2. Quindi, copia/incolla lo snippet dall'alto per definire la funzione `beforeEach()`.

3. Compiliamo il corpo della nostra nuova funzione. Vai avanti e **sposta** la riga di codice che crea una nuova istanza di contratto all'interno della funzione `beforeEach()`. Ora che abbiamo definito `contractInstance` da un'altra parte, rimuovi il qualificatore `const`.

4. Vorremo una nuova funzione `it` vuota per il nostro test. Imposta il nome del test (che Ã¨ il primo parametro che stiamo passando alla funzione `it`) uguale a "should not allow two zombies".

---

### ğŸ§Ÿâ€â™‚ï¸Eccoli... zombi di ogni tipo!!!ğŸ§Ÿâ€â™‚ï¸

Se vuoi davvero **_raggiungere la padronanza_**, vai avanti e continua a leggere. Altrimenti... fai clic su Avanti e vai al capitolo successivo.

Sei ancora qui?ğŸ˜

Stupendo! Dopotutto, perchÃ© dovresti negare a te stesso un sacco di meraviglie?

Ora, torniamo indietro a come funziona `contract.new`. Fondamentalmente, ogni volta che chiamiamo questa funzione, _Truffle_ fa in modo che venga distribuito un nuovo contratto.

Da un lato, questo Ã¨ utile perchÃ© ci consente di iniziare ogni test con un ambiente pulito.

D'altra parte, se tutti creassero innumerevoli contratti, la blockchain si riempirebbe inutilmente. Vogliamo che tu rimanga in giro, ma non vogliamo mantenere tutti i tuoi contratti di prova!

Vorremmo evitare che ciÃ² accada, giusto?

Fortunatamente, la soluzione Ã¨ piuttosto semplice... il nostro contratto dovrebbe "autodistruggersi" una volta che non Ã¨ piÃ¹ necessario.

Il modo in cui funziona Ã¨ il seguente:

- **prima**, vorremmo aggiungere una nuova funzione al contratto intelligente `CryptoZombie` in questo modo:

```sol
function kill() public onlyOwner {
    selfdestruct(owner());
}
```

> Nota: se vuoi saperne di piÃ¹ su `selfdestruct()`, puoi leggere i documenti _Solidity_ <a href="https://solidity.readthedocs.io/en/v0.4.21/introduction-to-smart-contracts. html#self-destruct" target=_blank>qui</a>. La cosa piÃ¹ importante da tenere a mente Ã¨ che la funzione "selfdestruct" Ã¨ l'_unico_ modo in cui il codice a un certo indirizzo puÃ² essere rimosso dalla blockchain. Questo lo rende una caratteristica piuttosto importante!

- **successivamente**, similmente alla funzione `beforeEach()` spiegata sopra, creeremo una funzione chiamata `afterEach()`:

```javascript
afterEach(async () => {
	await contractInstance.kill();
});
```

- **Infine**, _Truffle_ si assicurerÃ  che questa funzione venga chiamata dopo l'esecuzione di ogni test.

E voilÃ , lo smart contract si Ã¨ distrutto da solo!

Abbiamo ancora molti argomenti da trattare in questa lezione e l'implementazione di questa funzione richiederÃ  probabilmente almeno 2 capitoli aggiuntivi. Confidiamo che lo aggiungerai.ğŸ’ªğŸ»
