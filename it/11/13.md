---
title: Affermazioni più espressive con Chai
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const time = require("./helpers/time");
        //TODO: import expect into our project
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                //TODO: replace with expect
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner, bob);
                })
            })
            context("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner,bob);
                })
                it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.approve(bob, zombieId, {from: alice});
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    //TODO: replace with expect
                    assert.equal(newOwner,bob);
                 })
            })
            it("zombies should be able to attack another zombie", async () => {
                let result;
                result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                const firstZombieId = result.logs[0].args.zombieId.toNumber();
                result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
                const secondZombieId = result.logs[0].args.zombieId.toNumber();
                await time.increase(time.duration.days(1));
                await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
                //TODO: replace with expect
                assert.equal(result.receipt.status, true);
            })
        })

      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };
      'test/helpers/time.js': |
        async function increase(duration) {

            //first, let's increase time
            await web3.currentProvider.sendAsync({
                jsonrpc: "2.0",
                method: "evm_increaseTime",
                params: [duration], // there are 86400 seconds in a day
                id: new Date().getTime()
            }, () => {});

            //next, let's mine a new block
            web3.currentProvider.send({
                jsonrpc: '2.0',
                method: 'evm_mine',
                params: [],
                id: new Date().getTime()
            })

        }

        const duration = {

            seconds: function (val) {
                return val;
            },
            minutes: function (val) {
                return val * this.seconds(60);
            },
            hours: function (val) {
                return val * this.minutes(60);
            },
            days: function (val) {
                return val * this.hours(24);
            },
        }

        module.exports = {
            increase,
            duration,
        };

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const time = require("./helpers/time");

      var expect = require('chai').expect;

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              expect(result.receipt.status).to.equal(true);
              expect(result.logs[0].args.name).to.equal(zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
              })
          })
          context("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: bob});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
              })
              it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.approve(bob, zombieId, {from: alice});
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  expect(newOwner).to.equal(bob);
               })
          })
          it("zombies should be able to attack another zombie", async () => {
              let result;
              result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              const firstZombieId = result.logs[0].args.zombieId.toNumber();
              result = await contractInstance.createRandomZombie(zombieNames[1], {from: bob});
              const secondZombieId = result.logs[0].args.zombieId.toNumber();
              await time.increase(time.duration.days(1));
              await contractInstance.attack(firstZombieId, secondZombieId, {from: alice});
              expect(result.receipt.status).to.equal(true);
          })
      })
---

Finora abbiamo usato il modulo integrato `assert` per scrivere le nostre asserzioni. Sebbene non sia male, il modulo `assert` ha un grosso svantaggio: il codice non è facilmente leggibile. Fortunatamente, là fuori ci sono molti moduli che possono aiutarci e `Chai` è uno dei migliori.

## Libreria per asserzioni Chai

`Chai` è molto potente e, per lo scopo di questa lezione, ci limiteremo a scalfire la superficie. Una volta terminata questa lezione, non esitare a consultare le <a href=" https://www.chaijs.com/guide/" target=_blank>loro guide</a> per approfondire le tue conoscenze e ottenere maggiori dettagli.

Detto questo, diamo un'occhiata ai tre tipi di stili di asserzione raggruppati in `Chai`:

- _expect_: consente di concatenare asserzioni in linguaggio naturale come segue:

  ```javascript
  let lessonTitle = 'Testing Smart Contracts with Truffle';
  expect(lessonTitle).to.be.a('string');
  ```

- _should_: consente asserzioni simili all'interfaccia `expect`, ma la catena inizia con una proprietà `should`:

  ```javascript
  let lessonTitle = 'Testing Smart Contracts with Truffle';
  lessonTitle.should.be.a('string');
  ```

- _assert_: fornisce una notazione simile a quella confezionata con node.js e include diversi test aggiuntivi, è compatibile con il browser:

```javascript
let lessonTitle = 'Testing Smart Contracts with Truffle';
assert.typeOf(lessonTitle, 'string');
```

In questo capitolo, ti mostreremo come migliorare le tue asserzioni utilizzando `expect`.

> Nota: supponiamo che il pacchetto `chai` sia già installato sul tuo computer. In caso contrario, puoi installarlo facilmente in questo modo: `npm -g install chai`

Per usare lo stile `expect`, la prima cosa che dovremmo fare è importarlo nel nostro progetto come segue:

```javascript
var expect = require('chai').expect;
```

## expect().to.equal()

Ora che abbiamo importato `expect` nel nostro progetto, potresti controllare se due stringhe sono nel seguente modo:

```javascript
let zombieName = 'My Awesome Zombie';
expect(zombieName).to.equal('My Awesome Zombie');
```

Basta parlare. Sfruttiamo i poteri di `Chai`!

# Testiamo

1.  Importiamo `expect` nel nostro progetto.

2.  Continuando l'esempio sopra con `zombieName`, possiamo usare `expect` per testare una transazione riuscita come segue:

```javascript
expect(result.receipt.status).to.equal(true);
```

E possiamo verificare se Alice possiede uno zombi con il seguente codice:

```javascript
expect(zombieOwner).to.equal(alice);
```

1. Sostituisci tutte le occorrenze di `assert.equal` con `expect`. Abbiamo lasciato un sacco di commenti nel codice per renderli facili da trovare.
