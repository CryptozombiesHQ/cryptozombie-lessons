---
title: Il primo Test - Creazione di un nuovo zombi (continua)
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            it("should be able to create a new zombie", async () => {
                const contractInstance = await CryptoZombies.new();
                // start here
            })
        })
    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          it("should be able to create a new zombie", async () => {
              const contractInstance = await CryptoZombies.new();
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name, zombieNames[0]);
          })
      })
---

Ora che abbiamo le nostre papere -ehm zombie-, passiamo alla fase successiva... üßüü¶Ü‚Äçüßüü¶Üüßüü¶Ü‚Äçüßüü¶Üüßüü¶Ü‚Äçüßüü¶Ü

## 2. Act

Abbiamo raggiunto la parte in cui chiameremo la funzione che crea un nuovo zombie per Alice- `createRandomZombie`.

Ma c'√® un piccolo problema: come possiamo farlo in modo che il metodo "sa" chi lo chiama? Un altro modo per dirla sarebbe: come possiamo assicurarci che Alice (e non Bob) sar√† la proprietaria di questo nuovo zombi?üßê

Bene... il problema √® risolto con la '_contract abstraction_'. Una delle caratteristiche di _Truffle_ √® che racchiude l'implementazione originale di _Solidity_ e ci consente di specificare l'indirizzo che effettua la chiamata alla funzione passando quell'indirizzo come argomento.

Il seguente chiama `createRandomZombie` e si assicura che `msg.sender` sia impostato sull'indirizzo di Alice:

```javascript
const result = await contractInstance.createRandomZombie(zombieNames[0], {
	from: alice,
});
```

Ora ho una domanda veloce per te: sai cosa viene memorizzato in `result`?

#### Logs ed Eventi

Una volta specificato il contratto che volevamo testare usando `artifacts.require`, _Truffle_ fornisce automaticamente i log generati dal nostro smart contract. Ci√≤ significa che ora possiamo recuperare il `nome` dello zombi appena creato da Alice usando qualcosa del genere: `result.logs[0].args.name`. In modo simile, possiamo ottenere `id` e `_dna`.

Oltre a queste informazioni, "result" ci fornir√† molti altri dettagli utili sulla transazione:

- `result.tx`: hash della transazione
- `result.receipt`: un oggetto contenente la ricevuta della transazione. Se `result.receipt.status` √® uguale a `true` significa che la transazione √® andata a buon fine. In caso contrario, significa che la transazione non √® riuscita.

> Nota: tieni presente che i registri possono essere utilizzati anche come opzione molto pi√π economica per archiviare i dati. Lo svantaggio √® che non √® possibile accedervi dall'interno dello smart contract stesso.

## 3. Assertion

In questo capitolo useremo il modulo di asserzione integrato che viene fornito con un insieme di funzioni di asserzione come `equal()` e `deepEqual()`. In poche parole, queste funzioni controllano la condizione e 'generano' un errore se il risultato non √® quello previsto. Poich√© confronteremo valori semplici, eseguiremo `assert.equal()`.

# Testiamo

Concludiamo il nostro primo test.

1.  Dichiara una variabile `const` chiamata `result` e impostala uguale al risultato di `contractInstance.createRandomZombie` con il nome dello zombi e il proprietario come argomenti (alice).

2.  Una volta ottenuto il `risultato`, chiama `assert.equal` con due argomenti: `result.receipt.status` e `true`.

Se la condizione del punto 2. √® vera, possiamo presumere che il nostro test sia stato superato. Per sicurezza, dato che siamo qui, possiamo aggiungere un altro controllo.

1.  Nella riga successiva, controlliamo se `result.logs[0].args.name` √® uguale a `zombieNames[0]`. Usa `assert.equal`, proprio come abbiamo fatto sopra.

Ora √® il momento di eseguire il nostro primo "test di Truffle" e vedere se va a buon fine. Il modo in cui funziona √® che _Truffle_ ispezioner√† semplicemente la directory _"test"_ ed eseguir√† i file che trova l√¨.

In realt√†, siamo andati avanti e l'abbiamo fatto per te. L'output dovrebbe assomigliare a questo:

```bash
Contract: CryptoZombies
    ‚úì should be able to create a new zombie (323ms)


  1 passing (768ms)
```

Questo conclude il tuo primo test: ben fatto! Ce ne sono molti altri in arrivo, quindi andiamo avanti con la prossima lezione...
