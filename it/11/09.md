---
title: Trasferimento token ERC721- Scenario a singolo step
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
            })
            xcontext("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                  // start here.
                })
            })
            xcontext("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                  // TODO: Test the two-step scenario.  The approved address calls transferFrom
                })
                it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                    // TODO: Test the two-step scenario.  The owner calls transferFrom
                 })
            })
        })
      'test/helpers/utils.js': |
        async function shouldThrow(promise) {
        try {
            await promise;
            assert(true);
        }
        catch (err) {
            return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
            shouldThrow,
        };
    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      const utils = require("./helpers/utils");

      const zombieNames = ["Zombie 1", "Zombie 2"];

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          let contractInstance;
          beforeEach(async () => {
              contractInstance = await CryptoZombies.new();
          });
          it("should be able to create a new zombie", async () => {
              const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              assert.equal(result.receipt.status, true);
              assert.equal(result.logs[0].args.name,zombieNames[0]);
          })
          it("should not allow two zombies", async () => {
              await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
              await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
          })
          context("with the single-step transfer scenario", async () => {
              it("should transfer a zombie", async () => {
                  const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                  const zombieId = result.logs[0].args.zombieId.toNumber();
                  await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                  const newOwner = await contractInstance.ownerOf(zombieId);
                  assert.equal(newOwner, bob);
              })
          })
          xcontext("with the two-step transfer scenario", async () => {
              it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
                // TODO: Test the two-step scenario.  The approved address calls transferFrom
              })
              it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
                  // TODO: Test the two-step scenario.  The owner calls transferFrom
               })
          })
      })
---

Finora ci siamo solo riscaldati...

Ma ora √® il momento di mostrare davvero quello che imparato!

Nei prossimi capitoli metteremo insieme ci√≤ che abbiamo imparato e proveremo qualcosa di veramente interessante.

Per cominciare, testeremo lo scenario in cui _Alice_ trasferisce il suo token ERC721 a _Bob_, in un unico passaggio.

Ecco cosa dovrebbe fare il nostro test:

- Creare un nuovo zombi per Alice (ricorda che uno zombi non √® altro che un token ERC721).

- Fai in modo che Alice trasferisca il suo token ERC721 a Bob.

- A questo punto, Bob dovrebbe possedere il token ERC721. In tal caso, `ownerOf` restituir√† un valore uguale all'indirizzo di Bob.

- Chiudiamo controllando se Bob √® il `newOwner`, all'interno di un `assert`.

# Testiamo

1. La prima riga della funzione dovrebbe chiamare `createRandomZombie`. Dagli `zombieNames[0]` come nome e assicurati che Alice sia la proprietaria.

2. La seconda riga dovrebbe dichiarare un `const` chiamato `zombieId` e impostarlo uguale all'id dello zombi. Nel <a href="https://cryptozombies.io/en/lesson/11/chapter/5" target=_new>Capitolo 5</a>, hai imparato come recuperare informazioni da log ed eventi nel nostro smart contract. Ripassa il capitolo se necessario. Assicurati di convertire anche `zombieId` in un numero valido utilizzando `toNumber()`.

3. Quindi, usiamo `transferFrom` con `alice` e `bob` come primi parametri. Assicurati che Alice chiami questa funzione e utilizza `await` per aspettare che termini l'esecuzione prima di andare avanti.

4. Dichiara un `const` chiamato `newOwner`. Impostalo uguale a `ownerOf` chiamato con `zombieId`.

5.Infine, controlliamo se Bob possiede questo token ERC721. Per far ci√≤ possiamo utilizzare `assert.equal` passando `newOwner` e `bob` come parametri;

> Nota: `assert.equal(newOwner, bob)` e `assert.equal(bob, newOwner)` sono fondamentalmente la stessa cosa. Ma il nostro interprete della riga di comando non √® troppo avanzato, quindi non considerer√† la tua risposta corretta a meno che tu non digiti la prima opzione.

1. Avevamo detto che il passaggio precedente era l'ultimo! Beh... era una bugia. L'ultima cosa che vogliamo fare √® rimuovere il blocco che salta l'esecuzione del primo scenario rimuovendo la `x` dal nome dalla funzione.

Fiuu! √à un sacco di codice. Spero che tu riesca a farlo bene. In caso contrario, sentiti libero di fare clic su "mostra risposta".

Adesso lanciamo `truffle test` e vediamo se i nostri test vengono verificati:

```bash
Contract: CryptoZombies
  ‚úì should be able to create a new zombie (146ms)
  ‚úì should not allow two zombies (235ms)
  with the single-step transfer scenario
    ‚úì should transfer a zombie (382ms)
  with the two-step transfer scenario
    - should approve and then transfer a zombie when the owner calls transferFrom
    - should approve and then transfer a zombie when the approved address calls transferFrom


3 passing (1s)
2 pending
```

Ed eccolo! Il nostro codice ha superato il test a pieni votiüëèüèª.

Nel prossimo capitolo, passeremo allo scenario in 2 fasi in cui "approve" √® seguito da "transferFrom".
