---
title: Il primo test - Creazione di uno zombie
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      'test/CryptoZombies.js': |
        const CryptoZombies = artifacts.require("CryptoZombies");
        contract("CryptoZombies", (accounts) => {
            //1. initialize `alice` and `bob`
            it("should be able to create a new zombie", () => { //2. Make the callback async
            })
        })

    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");

      contract("CryptoZombies", (accounts) => {
          let [alice, bob] = accounts;
          it("should be able to create a new zombie", async () => {
          })
      })
---

Prima di rilasciare il tuo codice su **Ethereum**, √® meglio testare i tuoi smart contract in locale.

Puoi farlo utilizzando uno strumento chiamato <a href="https://truffleframework.com/ganache" target=_blank>Ganache</a>, che installa un network **Ethereum** in locale.

Ogni volta che _Ganache_ viene avviato, crea 10 account di prova e fornisce loro 100 Ether per semplificare i test. Poich√© _Ganache_ e _Truffle_ sono strettamente integrati, possiamo accedere a questi account attraverso l'array `accounts` che abbiamo menzionato nel capitolo precedente.

Ma usare `accounts[0]` e `accounts[1]` non renderebbe i nostri testi facilmente leggibili, giusto?

Per facilitare la comprensione, utilizzeremo dei placeholder: Alice e Bob. Quindi, all'interno della funzione `contract()`, inizializziamoli in questo modo:

```javascript
let [alice, bob] = accounts;
```

> Nota: perdona la scarsa grammatica. In _JavaScript_, la convenzione prevede l'utilizzo di lettere minuscole per i nomi delle variabili.

Perch√© Alice e Bob? C'√® una grande tradizione che rende "Alice e Bob" o pi√π brevemente "A e B" ampiamente utilizzati in crittografia, fisica, programmazione e altro ancora. √à una storia breve ma interessante, e vale la pena <a href="http://cryptocouple.com/" target=_blank>leggere</a> dopo il completamento di questa lezione.

Ora facciamo il nostro primo test.

## Creazione di un nuovo Zombie

Supponiamo che Alice voglia giocare al nostro fantastico gioco. Se √® cos√¨, la prima cosa che vorrebbe fare √® **creare il proprio zombi üßü**. Per farlo, il front-end (o _Truffle_ nel nostro caso) dovrebbe chiamare la funzione `createRandomZombie`.

> Nota: per rifrescare la memoria riportiamo il codice _Solidity_ nel nostro contratto:

```sol
function createRandomZombie(string _name) public {
  require(ownerZombieCount[msg.sender] == 0);
  uint randDna = _generateRandomDna(_name);
  randDna = randDna - randDna % 100;
  _createZombie(_name, randDna);
}
```

Iniziamo testando questa funzione

# Testiamo

1.  La prima riga della funzione `contract()` dovrebbe dichiarare due variabili chiamate `alice` e `bob` e inizializzarle come mostrato sopra.

2.  Successivamente, vorremmo chiamare correttamente la funzione `it()`. Il secondo parametro (una funzione di `callback`) "parler√†" con la blockchain, per questo doremo renderla asincrona. Basta anteporre la parola chiave `async`. In questo modo, ogni volta che questa funzione viene chiamata con la parola chiave `await`, il nostro test attende una risposta prima di procedere.

> Il funzionamento delle promises non √® tra gli scopi di questa lezione. Una volta terminata questa lezione, dai un'occhiata alla <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target=_blank>documentazione ufficiale </a> per approfondire l'argomento.
