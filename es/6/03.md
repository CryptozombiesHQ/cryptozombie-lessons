---
title: Hablando con Contratos
actions:
  - 'comprobarRespuesta'
  - 'pistas'
requireLogin: verdadero
material:
  editor:
    language: html
    startingCode:
      "index.html": |2
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>CryptoZombies front-end</title>
        <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script language="javascript" type="text/javascript" src="web3.min.js"></script>
        <!-- 1. Incluye cryptozombies_abi.js aquí -->
        </head>
        <body>

        <script>
        // 2. Comienza el código aquí

        window.addEventListener('load', function() {

        // Comprobando si Web3 ha sido inyectado por el navegador (Mist/MetaMask)
        if (typeof web3 !== 'undefined') {
        // Utiliza el proveedor de Mist/MetaMask
        web3js = new Web3(web3.currentProvider);
        } else {
         // Maneje el caso donde el usuario no tiene Metamask instalado
        // Probablemente les muestre un mensaje solicitándoles que instalen Metamask
        }

        // Ahora puedes comenzar tu aplicación & acceder libremente a web3:
        startApp()

        })
        </script>
        </body>
        </html>
      "cryptozombies_abi.js": |
        var cryptoZombiesABI = [
        {
        "constant": false,
        "inputs": [
        {
        "name": "_approved",
        "type": "address"
        },
        {
        "name": "_tokenId",
        "type": "uint256"
        }
        ],
        "name": "approve",
        "outputs": [],
        "payable": true,
        "stateMutability": "payable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_zombieId",
        "type": "uint256"
        }
        ],
        "name": "levelUp",
        "outputs": [],
        "payable": true,
        "stateMutability": "payable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_zombieId",
        "type": "uint256"
        },
        {
        "name": "_kittyId",
        "type": "uint256"
        }
        ],
        "name": "feedOnKitty",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [
        {
        "name": "",
        "type": "uint256"
        }
        ],
        "name": "zombies",
        "outputs": [
        {
        "name": "name",
        "type": "string"
        },
        {
        "name": "dna",
        "type": "uint256"
        },
        {
        "name": "level",
        "type": "uint32"
        },
        {
        "name": "readyTime",
        "type": "uint32"
        },
        {
        "name": "winCount",
        "type": "uint16"
        },
        {
        "name": "lossCount",
        "type": "uint16"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [],
        "name": "withdraw",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [
        {
        "name": "_owner",
        "type": "address"
        }
        ],
        "name": "getZombiesByOwner",
        "outputs": [
        {
        "name": "",
        "type": "uint256[]"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [
        {
        "name": "",
        "type": "uint256"
        }
        ],
        "name": "zombieToOwner",
        "outputs": [
        {
        "name": "",
        "type": "address"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_address",
        "type": "address"
        }
        ],
        "name": "setKittyContractAddress",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_zombieId",
        "type": "uint256"
        },
        {
        "name": "_newDna",
        "type": "uint256"
        }
        ],
        "name": "changeDna",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [
        {
        "name": "_tokenId",
        "type": "uint256"
        }
        ],
        "name": "ownerOf",
        "outputs": [
        {
        "name": "",
        "type": "address"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [
        {
        "name": "_owner",
        "type": "address"
        }
        ],
        "name": "balanceOf",
        "outputs": [
        {
        "name": "",
        "type": "uint256"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_name",
        "type": "string"
        }
        ],
        "name": "createRandomZombie",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [],
        "name": "owner",
        "outputs": [
        {
        "name": "",
        "type": "address"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_from",
        "type": "address"
        },
        {
        "name": "_to",
        "type": "address"
        },
        {
        "name": "_tokenId",
        "type": "uint256"
        }
        ],
        "name": "transferFrom",
        "outputs": [],
        "payable": true,
        "stateMutability": "payable",
        "type": "function"
        },
        {
        "constant": true,
        "inputs": [],
        "name": "getAllZombies",
        "outputs": [
        {
        "name": "",
        "type": "uint256[]"
        }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
        },
        "constant": false,
        "inputs": [
        {
        "name": "_zombieId",
        "type": "uint256"
        },
        {
        "name": "_newName",
        "type": "string"
        }
        ],
        "name": "changeName",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_fee",
        "type": "uint256"
        }
        ],
        "name": "setLevelUpFee",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "_zombieId",
        "type": "uint256"
        },
        {
        "name": "_targetId",
        "type": "uint256"
        }
        ],
        "name": "attack",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "constant": false,
        "inputs": [
        {
        "name": "newOwner",
        "type": "address"
        }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
        },
        {
        "anonymous": false,
        "inputs": [
        {
        "indexed": true,
        "name": "_from",
        "type": "address"
        },
        {
        "indexed": true,
        "name": "_to",
        "type": "address"
        },
        {
        "indexed": false,
        "name": "_tokenId",
        "type": "uint256"
        }
        ],
        "name": "Transfer",
        "type": "event"
        },
        {
        "anonymous": false,
        "inputs": [
        {
        "indexed": true,
        "name": "_owner",
        "type": "address"
        },
        {
        "indexed": true,
        "name": "_approved",
        "type": "address"
        },
        {
        "indexed": false,
        "name": "_tokenId",
        "type": "uint256"
        }
        ],
        "name": "Approval",
        "type": "event"
        },
        {
        "anonymous": false,
        "inputs": [
        {
        "indexed": false,
        "name": "attackResult",
        "type": "bool"
        },
        {
        "indexed": false,
        "name": "winCount",
        "type": "uint16"
        },
        {
        "indexed": false,
        "name": "lossCount",
        "type": "uint16"
        }
        ],
        "name": "AttackResult",
        "type": "event"
        },
        {
        "anonymous": false,
        "inputs": [
        {
        "indexed": false,
        "name": "zombieId",
        "type": "uint256"
        },
        {
        "indexed": false,
        "name": "name",
        "type": "string"
        },
        {
        "indexed": false,
        "name": "dna",
        "type": "uint256"
        }
        ],
        "name": "NewZombie",
        "type": "event"
        },
        {
        "anonymous": false,
        "inputs": [
        {
        "indexed": true,
        "name": "previousOwner",
        "type": "address"
        },
        {
        "indexed": true,
        "name": "newOwner",
        "type": "address"
        }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
        }
        ]
      "zombieownership.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        import "./zombieattack.sol";
        import "./erc721.sol";
        import "./safemath.sol";

        contract ZombieOwnership is ZombieAttack, ERC721 {

        using SafeMath for uint256;

        mapping (uint => address) zombieApprovals;

        function balanceOf(address _owner) external view returns (uint256) {
        return ownerZombieCount[_owner];
        }

        function ownerOf(uint256 _tokenId) external view returns (address) {
        return zombieToOwner[_tokenId];
        }

        function _transfer(address _from, address _to, uint256 _tokenId) private {
        ownerZombieCount[_to] = ownerZombieCount[_to].add(1);
        ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);
        zombieToOwner[_tokenId] = _to;
        emit Transfer(_from, _to, _tokenId);
        }

        function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
        require (zombieToOwner[_tokenId] == msg.sender || zombieApprovals[_tokenId] == msg.sender);
        _transfer(_from, _to, _tokenId);
        }

        function approve(address _approved, uint256 _tokenId) external payable onlyOwnerOf(_tokenId) {
        zombieApprovals[_tokenId] = _approved;
        emit Approval(msg.sender, _approved, _tokenId);
        }

        }
      "zombieattack.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        import "./zombiehelper.sol";

        contract ZombieAttack is ZombieHelper {
        uint randNonce = 0;
        uint attackVictoryProbability = 70;

        function randMod(uint _modulus) internal returns(uint) {
        randNonce = randNonce.add(1);
        return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus;
        }

        function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        Zombie storage enemyZombie = zombies[_targetId];
        uint rand = randMod(100);
        if (rand <= attackVictoryProbability) {
        myZombie.winCount = myZombie.winCount.add(1);
        myZombie.level = myZombie.level.add(1);
        enemyZombie.lossCount = enemyZombie.lossCount.add(1);
        feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
        } else {
        myZombie.lossCount = myZombie.lossCount.add(1);
        enemyZombie.winCount = enemyZombie.winCount.add(1);
        _triggerCooldown(myZombie);
        }
        }
        }
      "zombiehelper.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        import "./zombiefeeding.sol";

        contract ZombieHelper is ZombieFeeding {

        uint levelUpFee = 0.001 ether;

        modifier aboveLevel(uint _level, uint _zombieId) {
        require(zombies[_zombieId].level >= _level);
        _;
        }

        function withdraw() external onlyOwner {
        address _owner = owner();
        _owner.transfer(address(this).balance);
        }

        function setLevelUpFee(uint _fee) external onlyOwner {
        levelUpFee = _fee;
        }

        function levelUp(uint _zombieId) external payable {
        require(msg.value == levelUpFee);
        zombies[_zombieId].level = zombies[_zombieId].level.add(1);
        }

        function changeName(uint _zombieId, string calldata _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) {
        zombies[_zombieId].name = _newName;
        }

        function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) {
        zombies[_zombieId].dna = _newDna;
        }

        function getZombiesByOwner(address _owner) external view returns(uint[] memory) {
        uint[] memory result = new uint[](ownerZombieCount[_owner]);
        uint counter = 0;
        for (uint i = 0; i < zombies.length; i++) {
        if (zombieToOwner[i] == _owner) {
        result[counter] = i;
        counter++;
        }
        }
        return result;
        }

        }
      "zombiefeeding.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        import "./zombiefactory.sol";

        contract KittyInterface {
        function getKitty(uint256 _id) external view returns (
        bool isGestating,
        bool isReady,
        uint256 cooldownIndex,
        uint256 nextActionAt,
        uint256 siringWithId,
        uint256 birthTime,
        uint256 matronId,
        uint256 sireId,
        uint256 generation,
        uint256 genes
        );
        }

        contract ZombieFeeding is ZombieFactory {

        KittyInterface kittyContract;

        modifier onlyOwnerOf(uint _zombieId) {
        require(msg.sender == zombieToOwner[_zombieId]);
        _;
        }

        function setKittyContractAddress(address _address) external onlyOwner {
        kittyContract = KittyInterface(_address);
        }

        function _triggerCooldown(Zombie storage _zombie) internal {
        _zombie.readyTime = uint32(now + cooldownTime);
        }

        function _isReady(Zombie storage _zombie) internal view returns (bool) {
        return (_zombie.readyTime <= now);
        }

        function feedAndMultiply(uint _zombieId, uint _targetDna, string memory _species) internal onlyOwnerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        require(_isReady(myZombie));
        _targetDna = _targetDna % dnaModulus;
        uint newDna = (myZombie.dna + _targetDna) / 2;
        if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked("kitty"))) {
        newDna = newDna - newDna % 100 + 99;
        }
        _createZombie("NoName", newDna);
        _triggerCooldown(myZombie);
        }

        function feedOnKitty(uint _zombieId, uint _kittyId) public {
        uint kittyDna;
        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
        feedAndMultiply(_zombieId, kittyDna, "kitty");
        }
        }
      "zombiefactory.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        import "./ownable.sol";
        import "./safemath.sol";

        contract ZombieFactory is Ownable {

        using SafeMath for uint256;
        using SafeMath32 for uint32;
        using SafeMath16 for uint16;

        event NewZombie(uint zombieId, string name, uint dna);

        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
        uint cooldownTime = 1 days;

        struct Zombie {
        string name;
        uint dna;
        uint32 level;
        uint32 readyTime;
        uint16 winCount;
        uint16 lossCount;
        }

        Zombie[] public zombies;

        mapping (uint => address) public zombieToOwner;
        mapping (address => uint) ownerZombieCount;

        function _createZombie(string memory _name, uint _dna) internal {
        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
        zombieToOwner[id] = msg.sender;
        ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].add(1);
        emit NewZombie(id, _name, _dna);
        }

        function _generateRandomDna(string memory _str) private view returns (uint) {
        uint rand = uint(keccak256(abi.encodePacked(_str)));
        return rand % dnaModulus;
        }

        function createRandomZombie(string memory _name) public {
        require(ownerZombieCount[msg.sender] == 0);
        uint randDna = _generateRandomDna(_name);
        randDna = randDna - randDna % 100;
        _createZombie(_name, randDna);
        }

        }
      "ownable.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        /**
        * @title Ownable
        * @dev The Ownable contract has an owner address, and provides basic authorization control
        * functions, this simplifies the implementation of "user permissions".
        */
        contract Ownable {
        address private _owner;

        event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
        );

        /**
        * @dev The Ownable constructor sets the original `owner` of the contract to the sender
        * account.
        */
        constructor() internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
        }

        /**
        * @return the address of the owner.
        */
        function owner() public view returns(address) {
        return _owner;
        }

        /**
        * @dev Throws if called by any account other than the owner.
        */
        modifier onlyOwner() {
        require(isOwner());
        _;
        }

        /**
        * @return true if `msg.sender` is the owner of the contract.
        */
        function isOwner() public view returns(bool) {
        return msg.sender == _owner;
        }

        /**
        * @dev Allows the current owner to relinquish control of the contract.
        * @notice Renouncing to ownership will leave the contract without an owner.
        * It will not be possible to call the functions with the `onlyOwner`
        * modifier anymore.
        */
        function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
        }

        /**
        * @dev Allows the current owner to transfer control of the contract to a newOwner.
        * @param newOwner The address to transfer ownership to.
        */
        function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
        }

        /**
        * @dev Transfers control of the contract to a newOwner.
        * @param newOwner The address to transfer ownership to.
        */
        function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
        }
        }
      "safemath.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        /**
        * @title SafeMath
        * @dev Math operations with safety checks that throw on error
        */
        library SafeMath {

        /**
        * @dev Multiplies two numbers, throws on overflow.
        */
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
        return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
        }

        /**
        * @dev La división entera de dos números, omiten al cociente.
        */
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
        }

        /**
        * @dev Restar dos números, arroja un desbordamiento (es decir, si el sustraendo es mayor que el minuendo).
        */
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
        }

        /**
        * @dev Sumar dos números, arroja un desbordamiento.
        */
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
        }
        }

        /**
        * @title SafeMath32
        * @dev SafeMath library implemented for uint32
        */
        library SafeMath32 {

        function mul(uint32 a, uint32 b) internal pure returns (uint32) {
        if (a == 0) {
        return 0;
        }
        uint32 c = a * b;
        assert(c / a == b);
        return c;
        }

        function div(uint32 a, uint32 b) internal pure returns (uint32) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint32 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
        }

        function sub(uint32 a, uint32 b) internal pure returns (uint32) {
        assert(b <= a);
        return a - b;
        }

        function add(uint32 a, uint32 b) internal pure returns (uint32) {
        uint32 c = a + b;
        assert(c >= a);
        return c;
        }
        }

        /**
        * @title SafeMath16
        * @dev SafeMath library implemented for uint16
        */
        library SafeMath16 {

        function mul(uint16 a, uint16 b) internal pure returns (uint16) {
        if (a == 0) {
        return 0;
        }
        uint16 c = a * b;
        assert(c / a == b);
        return c;
        }

        function div(uint16 a, uint16 b) internal pure returns (uint16) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint16 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
        }

        function sub(uint16 a, uint16 b) internal pure returns (uint16) {
        assert(b <= a);
        return a - b;
        }

        function add(uint16 a, uint16 b) internal pure returns (uint16) {
        uint16 c = a + b;
        assert(c >= a);
        return c;
        }
        }
      "erc721.sol": |
        pragma solidity >=0.5.0 <0.6.0;

        contract ERC721 {
        event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
        event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

        function balanceOf(address _owner) external view returns (uint256);
        function ownerOf(uint256 _tokenId) external view returns (address);
        function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
        function approve(address _approved, uint256 _tokenId) external payable;
        }
    answer: |
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="UTF-8">
      <title>CryptoZombies front-end</title>
      <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
      <script language="javascript" type="text/javascript" src="web3.min.js"></script>
      <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
      </head>
      <body>

      <script>
      var cryptoZombies;

      function startApp() {
      var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
      cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);
      }

      window.addEventListener('load', function() {

      // Checking if Web3 has been injected by the browser (Mist/MetaMask)
      if (typeof web3 !== 'undefined') {
      // Use Mist/MetaMask's provider
      web3js = new Web3(web3.currentProvider);
      } else {
      // Handle the case where the user doesn't have Metamask installed
      // Probably show them a message prompting them to install Metamask
      }

      // Now you can start your app & access web3 freely:
      startApp()

      })
      </script>
      </body>
      </html>
---

Ahora que ya hemos inicializado Web3.js con el proveedor Web3 de MetaMask, vamos a configurarlo para hablar con nuestro contrato inteligente.

Web3.js va a necesitar dos cosas para poder hablar con tu contrato inteligente: su ***dirección*** y su ***ABI***.

## Dirección del Contrato

Después de terminar de escribir tu contrato inteligente, lo tendrás que compilar y desplegar en Ethereum. Vamos a cubrir el **despliegue** en la **siguiente lección**, pero ya que es un proceso bastante diferente de escribir código, hemos decidido salirnos del orden y cubrir primero Web3.js.

Después de implementar tu contrato, obtiene una dirección fija en Ethereum donde vivirá por siempre. If you recall from Lesson 2, the address of the CryptoKitties contract on Ethereum mainnet is `0x06012c8cf97BEaD5deAe237070F9587f8E7A266d`.

Deberás copiar esta dirección después de desplegar para poder hablar con su contrato inteligente.

## Contrato ABI

La otra cosa que Web3.js necesitará para hablar con tu contrato es su ***ABI***.

ABI significa Application Binary Interface en ingles. Básicamente es una representación de los métodos de sus contratos en formato JSON que le dice a Web3.js cómo formatear las llamadas de función de una manera que su contrato lo entienda.

When you compile your contract to deploy to Ethereum (which we'll cover in Lesson 7), the Solidity compiler will give you the ABI, so you'll need to copy and save this in addition to the contract address.

Since we haven't covered deployment yet, for this lesson we've compiled the ABI for you and put it in a file named `cryptozombies_abi.js`, stored in variable called `cryptoZombiesABI`.

If we include `cryptozombies_abi.js` in our project, we'll be able to access the CryptoZombies ABI using that variable.

## Instantiating a Web3.js Contract

Once you have your contract's address and ABI, you can instantiate it in Web3 as follows:

    // Instantiate myContract
    var myContract = new web3js.eth.Contract(myABI, myContractAddress);
    

## Put it to the Test

1. In the `<head>` of our document, include another script tag for `cryptozombies_abi.js` so we can import the ABI definition into our project.

2. At the beginning of our `<script>` tag in the `<body>`, declare a `var` named `cryptoZombies`, but don't set it equal to anything. Later we'll use this variable to store our instantiated contract.

3. Next, create a `function` named `startApp()`. We'll fill in the body in the next 2 steps.

4. The first thing `startApp()` should do is declare a `var` named `cryptoZombiesAddress` and set it equal to the string `"YOUR_CONTRACT_ADDRESS"` (this is the address of the CryptoZombies contract on mainnet).

5. Lastly, let's instantiate our contract. Set `cryptoZombies` equal to an new `web3js.eth.Contract` like we did in the example code above. (Using `cryptoZombiesABI`, which gets imported with our script tag, and `cryptoZombiesAddress` from above).