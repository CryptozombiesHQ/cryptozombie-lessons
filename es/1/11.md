---
title: The Oracle Contract
actions:
  - 'checkAnswer'
  - 'hints'
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "oracle/EthPriceOracle.sol": |
        pragma solidity 0.5.0;
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        import "./CallerContractInterface.sol";
        contract EthPriceOracle is Ownable {
        uint private randNonce = 0;
        uint private modulus = 1000;
        mapping(uint256=>bool) pendingRequests;
        event GetLatestEthPriceEvent(address callerAddress, uint id);
        event SetLatestEthPriceEvent(uint256 ethPrice, address callerAddress);
        function getLatestEthPrice() public returns (uint256) {
        randNonce++;
        uint id = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % modulus;
        pendingRequests[id] = true;
        emit GetLatestEthPriceEvent(msg.sender, id);
        return id;
        }
        function setLatestEthPrice(uint256 _ethPrice, address _callerAddress,   uint256 _id) public onlyOwner {
        require(pendingRequests[_id], "This request is not in my pending list.");
        delete pendingRequests[_id];
        // Start here
        }
        }
      "caller/CallerContract.sol": |
        pragma solidity 0.5.0;
        import "./EthPriceOracleInterface.sol";
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        contract CallerContract is Ownable {
        uint256 private ethPrice;
        EthPriceOracleInterface private oracleInstance;
        address private oracleAddress;
        mapping(uint256=>bool) myRequests;
        event newOracleAddressEvent(address oracleAddress);
        event ReceivedNewRequestIdEvent(uint256 id);
        event PriceUpdatedEvent(uint256 ethPrice, uint256 id);
        function setOracleInstanceAddress (address _oracleInstanceAddress) public onlyOwner {
        oracleAddress = _oracleInstanceAddress;
        oracleInstance = EthPriceOracleInterface(oracleAddress);
        emit newOracleAddressEvent(oracleAddress);
        }
        function updateEthPrice() public {
        uint256 id = oracleInstance.getLatestEthPrice();
        myRequests[id] = true;
        emit ReceivedNewRequestIdEvent(id);
        }
        function callback(uint256 _ethPrice, uint256 _id) public onlyOracle {
        require(myRequests[_id], "This request is not in my pending list.");
        ethPrice = _ethPrice;
        delete myRequests[_id];
        emit PriceUpdatedEvent(_ethPrice, _id);
        }
        modifier onlyOracle() {
        require(msg.sender == oracleAddress, "You are not authorized to call this function.");
        _;
        }
        }
      "caller/EthPriceOracleInterface.sol": |
        pragma solidity 0.5.0;
        contract EthPriceOracleInterface {
        function getLatestEthPrice() public returns (uint256);
        }
      "oracle/CallerContractInterface.sol": |
        pragma solidity 0.5.0;
        contract CallerContracInterface {
        function callback(uint256 _ethPrice, uint256 id) public;
        }
    answer: |
      pragma solidity 0.5.0;
      import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
      import "./CallerContractInterface.sol";
      contract EthPriceOracle is Ownable {
      uint private randNonce = 0;
      uint private modulus = 1000;
      mapping(uint256=>bool) pendingRequests;
      event GetLatestEthPriceEvent(address callerAddress, uint id);
      event SetLatestEthPriceEvent(uint256 ethPrice, address callerAddress);
      function getLatestEthPrice() public returns (uint256) {
      randNonce++;
      uint id = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % modulus;
      pendingRequests[id] = true;
      emit GetLatestEthPriceEvent(msg.sender, id);
      return id;
      }
      function setLatestEthPrice(uint256 _ethPrice, address _callerAddress, uint256 _id) public onlyOwner {
      require(pendingRequests[_id], "This request is not in my pending list.");
      delete pendingRequests[_id];
      CallerContracInterface callerContractInstance;
      callerContractInstance = CallerContracInterface(_callerAddress);
      callerContractInstance.callback(_ethPrice, _id);
      emit SetLatestEthPriceEvent(_ethPrice, _callerAddress);
      }
      }
---
 
The `setLatestEthPrice` function is almost finished. Next, you'll have to:

* Instantiate the `CallerContractInstance`. In case you forgot how to do this or you need a bit of inspiration, take a quick glance at the following example:
  ```solidity
  MyContractInterface myContractInstance;
  myContractInstance = MyContractInterface(contractAddress)
  ```
* With the caller contract instantiated, you can now execute its `callback` method and pass it the new ETH price and the `id` of the request.
* Lastly, you'd want to fire an event to notify the front-end that the price has been successfully updated.

## Put It to the Test

1. Let's create a `CallerContracInterface` named `callerContractInstance`.
2. Initialize `callerContractInstance` with the address of the caller contract, just like we did with `myContractInstance` above. Note that the address of the caller contract should come from the function parameters.
3. Run the `callerContractInstance.callback` function, passing it `_ethPrice` and `_id`.
4. Lastly, `emit` the `SetLatestEthPriceEvent`. It takes two parameters: `_ethPrice` and `_callerAddress`.

Give yourself a pat on the back, you just finished writing the oracle smart contract!üí™üèªüí™üèªüí™üèª
