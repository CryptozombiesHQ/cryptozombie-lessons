---
title: Tokens en Ethereum
actions:
  - 'comprobarRespuesta'
  - 'pistas'
requireLogin: verdadero
material:
  editor:
    language: sol
    startingCode:
      "zombieownership.sol": |
        // Iniciar aquí
      "zombieattack.sol": |
        pragma solidity ^0.4.19;
        
        import "./zombiehelper.sol";
        
        contract ZombieAttack is ZombieHelper {
        uint randNonce = 0;
        uint attackVictoryProbability = 70;
        
        function randMod(uint _modulus) internal returns(uint) {
        randNonce++;
        return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
        }
        
        function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        Zombie storage enemyZombie = zombies[_targetId];
        uint rand = randMod(100);
        if (rand <= attackVictoryProbability) {
        myZombie.winCount++;
        myZombie.level++;
        enemyZombie.lossCount++;
        feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
        } else {
        myZombie.lossCount++;
        enemyZombie.winCount++;
        _triggerCooldown(myZombie);
        }
        }
        }
      "zombiehelper.sol": |
        pragma solidity ^0.4.19;
        
        import "./zombiefeeding.sol";
        
        contract ZombieHelper is ZombieFeeding {
        
        uint levelUpFee = 0.001 ether;
        
        modifier aboveLevel(uint _level, uint _zombieId) {
        require(zombies[_zombieId].level >= _level);
        _;
        }
        
        function withdraw() external onlyOwner {
        owner.transfer(this.balance);
        }
        
        function setLevelUpFee(uint _fee) external onlyOwner {
        levelUpFee = _fee;
        }
        
        function levelUp(uint _zombieId) external payable {
        require(msg.value == levelUpFee);
        zombies[_zombieId].level++;
        }
        
        function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
        zombies[_zombieId].name = _newName;
        }
        
        function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
        zombies[_zombieId].dna = _newDna;
        }
        
        function getZombiesByOwner(address _owner) external view returns(uint[]) {
        uint[] memory result = new uint[](ownerZombieCount[_owner]);
        uint counter = 0;
        for (uint i = 0; i < zombies.length; i++) {
        if (zombieToOwner[i] == _owner) {
        result[counter] = i;
        counter++;
        }
        }
        return result;
        }
        
        }
      "zombiefeeding.sol": |
        pragma solidity ^0.4.19;
        
        import "./zombiefactory.sol";
        
        contract KittyInterface {
        function getKitty(uint256 _id) external view returns (
        bool isGestating,
        bool isReady,
        uint256 cooldownIndex,
        uint256 nextActionAt,
        uint256 siringWithId,
        uint256 birthTime,
        uint256 matronId,
        uint256 sireId,
        uint256 generation,
        uint256 genes
        );
        }
        
        contract ZombieFeeding is ZombieFactory {
        
        KittyInterface kittyContract;
        
        modifier ownerOf(uint _zombieId) {
        require(msg.sender == zombieToOwner[_zombieId]);
        _;
        }
        
        function setKittyContractAddress(address _address) external onlyOwner {
        kittyContract = KittyInterface(_address);
        }
        
        function _triggerCooldown(Zombie storage _zombie) internal {
        _zombie.readyTime = uint32(now + cooldownTime);
        }
        
        function _isReady(Zombie storage _zombie) internal view returns (bool) {
        return (_zombie.readyTime <= now);
        }
        
        function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        require(_isReady(myZombie));
        _targetDna = _targetDna % dnaModulus;
        uint newDna = (myZombie.dna + _targetDna) / 2;
        if (keccak256(_species) == keccak256("kitty")) {
        newDna = newDna - newDna % 100 + 99;
        }
        _createZombie("NoName", newDna);
        _triggerCooldown(myZombie);
        }
        
        function feedOnKitty(uint _zombieId, uint _kittyId) public {
        uint kittyDna;
        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
        feedAndMultiply(_zombieId, kittyDna, "kitty");
        }
        }
      "zombiefactory.sol": |
        pragma solidity ^0.4.19;
        
        import "./ownable.sol";
        
        contract ZombieFactory is Ownable {
        
        event NewZombie(uint zombieId, string name, uint dna);
        
        uint dnaDigits = 16;
        uint dnaModulus = 10 ** dnaDigits;
        uint cooldownTime = 1 days;
        
        struct Zombie {
        string name;
        uint dna;
        uint32 level;
        uint32 readyTime;
        uint16 winCount;
        uint16 lossCount;
        }
        
        Zombie[] public zombies;
        
        mapping (uint => address) public zombieToOwner;
        mapping (address => uint) ownerZombieCount;
        
        function _createZombie(string _name, uint _dna) internal {
        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
        zombieToOwner[id] = msg.sender;
        ownerZombieCount[msg.sender]++;
        NewZombie(id, _name, _dna);
        }
        
        function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
        }
        
        function createRandomZombie(string _name) public {
        require(ownerZombieCount[msg.sender] == 0);
        uint randDna = _generateRandomDna(_name);
        randDna = randDna - randDna % 100;
        _createZombie(_name, randDna);
        }
        
        }
      "ownable.sol": |
        /**
        * @title Apropiable
        * @dev El Contraro Apropiable tiene una dirección de propietario, y proporciona un control de autorización básico
        * funciones, esto simplifica la implementación de "permisos de usuario".
        */
        contract Ownable {
        address public owner;
        
        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
        
        /**
        * @dev El constructor del contrato apropiable establece el `propietario` original del contrato para el remitente
        * account.
        */
        function Ownable() public {
        owner = msg.sender;
        }
        
        
        /**
        * @dev Lo arroja si lo llama cualquier cuenta que no sea el propietario.
        */
        modifier onlyOwner() {
        require(msg.sender == owner);
        _;
        }
        
        
        /**
        * @dev Permite al propietario actual transferir el control del contrato a un newOwner (nuevo propietario).
        * @param newOwner La dirección para transferir la propiedad a.
        */
        function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        }
        
        }
    answer: |
      pragma solidity ^0.4.19;
      
      import "./zombieattack.sol";
      
      contract ZombieOwnership is ZombieAttack {
      
      }
---
Hablemos sobre ***tokens***.

Si has estado en el ecosistema de Ethereum durante un tiempo, es probable que hayas oído hablar de los tokens — específicamente, de los ***_tokens ERC20***.

Un ***token*** es básicamente un contrato inteligente que sigue algunas reglas comunes, es decir, implementa un conjunto estándar de funciones que comparten el resto de tokens (contratos), como por ejemplo `transfer(address _to, uint256 _value)` y `balanceOf(address _owner)`.

Internament, el contrato inteligente tiene por lo general un mapeo, `mapping(address => uint256) balances`, que realiza un seguimiento de cuánto saldo tiene cada dirección.

Así que, básicamente, un token es sólo un contrato que realiza un seguimiento de quién posee la cantidad de ese token y algunas funciones para que los usuarios puedan transferir sus tokens a otras direcciones.

### ¿Por qué importa?

Dado que todos los tokens ERC20 comparten el mismo conjunto de funciones con los mismos nombres, todos pueden interactuar de la misma manera.

Esto significa que si creas una aplicación que es capaz de interactuar con un token de tipo ERC20, también será capaz de interactuar con cualquier token de tipo ERC20. De esta forma, más tokens se pueden añadir fácilmente a su aplicación en el futuro, sin necesidad de tener códigos personalizados por cada token ERC20. Simplemente puede conectar la nueva dirección de contrato del token y boom, tu aplicación tiene otro token que puede usar.

Un ejemplo de esto sería un exchange (casa de cambio). Cuando un exchange añade un nuevo token ERC20, realmente solo necesita agregar otro contrato inteligente con el que comunicarse. Los usuarios pueden indicarle a ese contrato que envíe los tokens a la dirección de su monedero en el exchange, y el exchange puede indicarle al contrato que devuelva los tokens a los usuarios cuando soliciten un retiro.

El exchange solo necesita implementar esta lógica de transferencia una vez, luego, cuando quiera añadir un nuevo token ERC20, es simplemente una cuestión de añadir la nueva dirección del contrato a su base de datos.

### Otros estándares del token

Los tokens ERC20 son realmente geniales porque actúan como si fueran monedas. Pero no son particularmente útiles para representar zombis en nuestro juego zombi.

Por un lado, los zombis no son divisibles como las monedas - puedo enviarte 0.237 ETH, pero transferir 0.237 de un zombi en realidad no tiene sentido.

En segundo lugar, todos los zombis no son creados de la misma manera. Tu zombi de nivel 2 "**Steve**"no es igual a mi zombi de nivel 732 "**H4XF13LD MORRIS (Ni estás cerca de serlo, *Steve*).</p> 

Hay otro estándar de token que encaja mucho mejor para los cripto-coleccionables como CryptoZombies — y se llaman ***tokens ERC721.***

Los ***tokens ERC721*** **no son intercambiables entre sí**, ya que se supone que cada uno de ellos es totalmente único e indivisible. Solo se pueden intercambiar en unidades completas, y cada uno tiene una ID única. Así que estos, son perfectos para hacer que nuestros zombis sean comerciables.

> Nota: Ten en cuenta que el uso de un estándar como ERC721 tiene el beneficio de que no tenemos que implementar la subasta o la lógica de plica en nuestro contrato que determina cómo los jugadores pueden comerciar / vender nuestros zombis. Si cumplimos con la especificación, alguien más podría construir otra plataforma de intercambio para los activos ERC721, y nuestros zombis ERC721 se podrían usar en esa plataforma. Por lo tanto, existen beneficios claros en el uso de un token estándar en lugar de desarrollar tu propia lógica comercial.

## Vamos a probarlo

Vamos a profundizar en la implementación de ERC721 en el próximo capítulo. Pero primero, configuremos nuestra estructura de archivos para esta lección.

Vamos a almacenar toda la lógica ERC721 en un contrato llamado `ZombieOwnership`.

1. Declara nuestra versión de `pragma` en la parte superior del archivo (verifique la sintaxis de los archivos de las lecciones anteriores).

2. Este archivo deberá `import` (importar) de `zombieattack.sol`.

3. Declara un nuevo contrato `ZombieOwnership`, que herede de `ZombieAttack`. Deja el cuerpo del contrato vacío por el momento.