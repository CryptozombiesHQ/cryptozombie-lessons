---
title: Time Units
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: rust
    startingCode:
        "zombie_factory.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::{storage, zombie::Zombie};

            #[multiversx_sc::module]
            pub trait ZombieFactory: storage::Storage {
                fn create_zombie(&self, owner: ManagedAddress, name: ManagedBuffer, dna: u64) {
                    self.zombie_last_index().update(|id| {
                        self.new_zombie_event(*id, &name, dna);
                        // start here
                        self.zombies(id).set(Zombie {
                            name,
                            dna,
                        });
                        self.owned_zombies(&owner).insert(*id);
                        self.zombie_owner(id).set(owner);
                        *id += 1;
                    });
                }

                #[view]
                fn generate_random_dna(&self) -> u64 {
                    let mut rand_source = RandomnessSource::new();
                    let dna_digits = self.dna_digits().get();
                    let max_dna_value = u64::pow(10u64, dna_digits as u32);
                    rand_source.next_u64_in_range(0u64, max_dna_value)
                }

                #[endpoint]
                fn create_random_zombie(&self, name: ManagedBuffer) {
                    let caller = self.blockchain().get_caller();
                    require!(
                        self.owned_zombies(&caller).is_empty(),
                        "You already own a zombie"
                    );
                    let rand_dna = self.generate_random_dna();
                    self.create_zombie(caller, name, rand_dna);
                }

                #[event("newZombieEvent")]
                fn new_zombie_event(
                    &self,
                    #[indexed] zombie_id: usize,
                    name: &ManagedBuffer,
                    #[indexed] dna: u64,
                );
            }
        "zombie_feeding.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::{storage, zombie_factory};
            use crypto_kitties_proxy::Kitty;

            mod crypto_kitties_proxy {
                multiversx_sc::imports!();
                multiversx_sc::derive_imports!();

                #[type_abi]
                #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
                pub struct Kitty {
                    pub is_gestating: bool,
                    pub is_ready: bool,
                    pub cooldown_index: u64,
                    pub next_action_at: u64,
                    pub siring_with_id: u64,
                    pub birth_time: u64,
                    pub matron_id: u64,
                    pub sire_id: u64,
                    pub generation: u64,
                    pub genes: u64,
                }

                #[multiversx_sc::proxy]
                pub trait CryptoKitties {
                    #[endpoint]
                    fn get_kitty(&self, id: usize) -> Kitty;
                }
            }

            #[multiversx_sc::module]
            pub trait ZombieFeeding:
                storage::Storage
                + zombie_factory::ZombieFactory
            {
                #[endpoint]
                fn feed_and_multiply(&self, zombie_id: usize, target_dna: u64, species: ManagedBuffer) {
                    let caller = self.blockchain().get_caller();
                    require!(
                        caller == self.zombie_owner(&zombie_id).get(),
                        "Only the owner of the zombie can perform this operation"
                    );
                    let my_zombie = self.zombies(&zombie_id).get();
                    let dna_digits = self.dna_digits().get();
                    let max_dna_value = u64::pow(10u64, dna_digits as u32);
                    let verified_target_dna = target_dna % max_dna_value;
                    let mut new_dna = (my_zombie.dna + verified_target_dna) / 2;
                    if species == ManagedBuffer::from(b"kitty") {
                        new_dna = new_dna - new_dna % 100 + 99;
                    }
                    self.create_zombie(caller, ManagedBuffer::from(b"NoName"), new_dna);
                }

                #[callback]
                fn get_kitty_callback(
                    &self,
                    #[call_result] result: ManagedAsyncCallResult<Kitty>,
                    zombie_id: usize,
                ) {
                    match result {
                        ManagedAsyncCallResult::Ok(kitty) => {
                            let kitty_dna = kitty.genes;
                            self.feed_and_multiply(zombie_id, kitty_dna, ManagedBuffer::from(b"kitty"));
                        },
                        ManagedAsyncCallResult::Err(_) => {},
                    }
                }

                #[endpoint]
                fn feed_on_kitty(
                    &self,
                    zombie_id: usize,
                    kitty_id: usize,
                ) {
                let crypto_kitties_sc_address = self.crypto_kitties_sc_address().get();
                    self.kitty_proxy(crypto_kitties_sc_address)
                        .get_kitty(kitty_id)
                        .async_call()
                        .with_callback(self.callbacks().get_kitty_callback(zombie_id))
                        .call_and_exit();
                }

                #[proxy]
                fn kitty_proxy(&self, to: ManagedAddress) -> crypto_kitties_proxy::Proxy<Self::Api>;
            }
        "zombie.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            #[type_abi]
            #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
            pub struct Zombie<M: ManagedTypeApi> {
                pub name: ManagedBuffer<M>,
                pub dna: u64,
                pub level: u16,
                pub ready_time: u64,
            }
        "storage.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::zombie::Zombie;

            #[multiversx_sc::module]
            pub trait Storage {
                #[storage_mapper("dnaDigits")]
                fn dna_digits(&self) -> SingleValueMapper<u8>;

                #[storage_mapper("zombieLastIndex")]
                fn zombie_last_index(&self) -> SingleValueMapper<usize>;

                #[view]
                #[storage_mapper("zombies")]
                fn zombies(&self, id: &usize) -> SingleValueMapper<Zombie<Self::Api>>;

                #[view]
                #[storage_mapper("zombieOwner")]
                fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("zombieOwner")]
                fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("cryptoKittiesScAddress")]
                fn crypto_kitties_sc_address(&self) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("ownedZombies")]
                fn owned_zombies(&self, owner: &ManagedAddress) -> UnorderedSetMapper<usize>;

                #[view]
                #[storage_mapper("cooldownTime")]
                fn cooldown_time(&self) -> SingleValueMapper<u64>;
            }
        "lib.rs": |
            #![no_std]

            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            mod storage;
            mod zombie;
            mod zombie_factory;
            mod zombie_feeding;

            #[multiversx_sc::contract]
            pub trait ZombiesContract:
                zombie_factory::ZombieFactory
                + zombie_feeding::ZombieFeeding
                + storage::Storage
            {
                #[init]
                fn init(&self) {
                    self.dna_digits().set(16u8);
                    self.zombie_last_index().set(1usize);
                    self.cooldown_time().set(86400u64);
                }

                #[upgrade]
                fn upgrade(&self) {}

                #[only_owner]
                #[endpoint]
                fn set_crypto_kitties_sc_address(&self, address: ManagedAddress) {
                    self.crypto_kitties_sc_address().set(address);
                }
            }
    answer: |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie::Zombie};

        #[multiversx_sc::module]
        pub trait ZombieFactory: storage::Storage {
            fn create_zombie(&self, owner: ManagedAddress, name: ManagedBuffer, dna: u64) {
                self.zombie_last_index().update(|id| {
                    self.new_zombie_event(*id, &name, dna);
                    let cooldown_time = self.cooldown_time().get();
                    self.zombies(id).set(Zombie {
                        name,
                        dna,
                        level: 1u16,
                        ready_time: self.blockchain().get_block_timestamp() + cooldown_time,
                    });
                    self.owned_zombies(&owner).insert(*id);
                    self.zombie_owner(id).set(owner);
                    *id += 1;
                });
            }

            #[view]
            fn generate_random_dna(&self) -> u64 {
                let mut rand_source = RandomnessSource::new();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                rand_source.next_u64_in_range(0u64, max_dna_value)
            }

            #[endpoint]
            fn create_random_zombie(&self, name: ManagedBuffer) {
                let caller = self.blockchain().get_caller();
                require!(
                    self.owned_zombies(&caller).is_empty(),
                    "You already own a zombie"
                );
                let rand_dna = self.generate_random_dna();
                self.create_zombie(caller, name, rand_dna);
            }

            #[event("newZombieEvent")]
            fn new_zombie_event(
                &self,
                #[indexed] zombie_id: usize,
                name: &ManagedBuffer,
                #[indexed] dna: u64,
            );
        }
---

The `level` property is pretty self-explanatory. Later on, when we create a battle system, zombies who win more battles will level up over time and get access to more abilities.

The `readyTime` property requires a bit more explanation. The goal is to add a "cooldown period", an amount of time a zombie has to wait after feeding or attacking before it's allowed to feed / attack again. Without this, the zombie could attack and multiply 1,000 times per day, which would make the game way too easy.

In order to keep track of how much time a zombie has to wait until it can attack again, we can use Solidity's time units.

## Time units

In the MultiversX Rust framework time can be accessed through `self.blockchain().get_block_timestamp()` and will return the current unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970). The unix time as I write this is `1515527488`.

Having access to timestamp gives us the possibility to deal with time through calculus in order to design our Zombie `cooldown` feature.

## Put it to the test

Let's add a cooldown time to our DApp, and make it so zombies have to wait **1 day (or 86400 seconds)** after attacking or feeding to attack again.

We declared a `SingleValueMapper` for a `u64` called `cooldown_time`, and set it equal to `86400u64` inside the init.

Since we added a `level` and `ready_time` to our `Zombie` struct in the previous chapter, we need to update `create_zombie()` to use the correct number of arguments when we create a new `Zombie` struct.

1. Create a variable called `cooldown_time` that reads the value from inside the `cooldown_time` storage mapper.

2. Update the zombie constructor from inside the zombie storage set to add 2 more arguments: `116` (for `level`), and `self.blockchain().get_block_timestamp() + cooldown_time` (for `ready_time`).

`self.blockchain().get_block_timestamp() + cooldown_time` will equal the current unix timestamp (in seconds) plus the number of seconds in 1 day — which will equal the unix timestamp 1 day from now. Later we can compare to see if this zombie's `readyTime` is greater than `self.blockchain().get_block_timestamp()` to see if enough time has passed to use the zombie again.

We'll implement the functionality to limit actions based on `ready_time` in the next chapter.
