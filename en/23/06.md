---
title: Limiting Zoombie Feeding with Cooldown
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: rust
    startingCode:
        "zombie_feeding.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::{storage, zombie_factory};
            use crypto_kitties_proxy::Kitty;

            mod crypto_kitties_proxy {
                multiversx_sc::imports!();
                multiversx_sc::derive_imports!();

                #[type_abi]
                #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
                pub struct Kitty {
                    pub is_gestating: bool,
                    pub is_ready: bool,
                    pub cooldown_index: u64,
                    pub next_action_at: u64,
                    pub siring_with_id: u64,
                    pub birth_time: u64,
                    pub matron_id: u64,
                    pub sire_id: u64,
                    pub generation: u64,
                    pub genes: u64,
                }

                #[multiversx_sc::proxy]
                pub trait CryptoKitties {
                    #[endpoint]
                    fn get_kitty(&self, id: usize) -> Kitty;
                }
            }

            #[multiversx_sc::module]
            pub trait ZombieFeeding:
                storage::Storage
                + zombie_factory::ZombieFactory
            {
                #[endpoint]
                fn feed_and_multiply(&self, zombie_id: usize, target_dna: u64, species: ManagedBuffer) {
                    let caller = self.blockchain().get_caller();
                    require!(
                        caller == self.zombie_owner(&zombie_id).get(),
                        "Only the owner of the zombie can perform this operation"
                    );
                    // start here
                    let my_zombie = self.zombies(&zombie_id).get();
                    let dna_digits = self.dna_digits().get();
                    let max_dna_value = u64::pow(10u64, dna_digits as u32);
                    let verified_target_dna = target_dna % max_dna_value;
                    let mut new_dna = (my_zombie.dna + verified_target_dna) / 2;
                    if species == ManagedBuffer::from(b"kitty") {
                        new_dna = new_dna - new_dna % 100 + 99;
                    }
                    self.create_zombie(caller, ManagedBuffer::from(b"NoName"), new_dna);
                }

                fn trigger_cooldown(&self, zombie_id: usize) {
                    let cooldown_time = self.cooldown_time().get();
                    self.zombies(&zombie_id).update(|my_zombie| {
                        my_zombie.ready_time = self.blockchain().get_block_timestamp() + cooldown_time
                    });
                }

                #[view]
                fn is_ready(&self, zombie_id: usize) -> bool {
                    let my_zombie = self.zombies(&zombie_id).get();
                    my_zombie.ready_time <= self.blockchain().get_block_timestamp()
                }

                #[callback]
                fn get_kitty_callback(
                    &self,
                    #[call_result] result: ManagedAsyncCallResult<Kitty>,
                    zombie_id: usize,
                ) {
                    match result {
                        ManagedAsyncCallResult::Ok(kitty) => {
                            let kitty_dna = kitty.genes;
                            self.feed_and_multiply(zombie_id, kitty_dna, ManagedBuffer::from(b"kitty"));
                        },
                        ManagedAsyncCallResult::Err(_) => {},
                    }
                }

                #[endpoint]
                fn feed_on_kitty(
                    &self,
                    zombie_id: usize,
                    kitty_id: usize,
                ) {
                let crypto_kitties_sc_address = self.crypto_kitties_sc_address().get();
                    self.kitty_proxy(crypto_kitties_sc_address)
                        .get_kitty(kitty_id)
                        .async_call()
                        .with_callback(self.callbacks().get_kitty_callback(zombie_id))
                        .call_and_exit();
                }

                #[proxy]
                fn kitty_proxy(&self, to: ManagedAddress) -> crypto_kitties_proxy::Proxy<Self::Api>;
            }
        "zombie.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            #[type_abi]
            #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
            pub struct Zombie<M: ManagedTypeApi> {
                pub name: ManagedBuffer<M>,
                pub dna: u64,
                pub level: u16,
                pub ready_time: u64,
            }
        "zombie_factory.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::{storage, zombie::Zombie};

            #[multiversx_sc::module]
            pub trait ZombieFactory: storage::Storage {
                fn create_zombie(&self, owner: ManagedAddress, name: ManagedBuffer, dna: u64) {
                    self.zombie_last_index().update(|id| {
                        self.new_zombie_event(*id, &name, dna);
                        let cooldown_time = self.cooldown_time().get();
                        self.zombies(id).set(Zombie {
                            name,
                            dna,
                            level: 1u16,
                            ready_time: self.blockchain().get_block_timestamp() + cooldown_time,
                        });
                        self.owned_zombies(&owner).insert(*id);
                        self.zombie_owner(id).set(owner);
                        *id += 1;
                    });
                }

                #[view]
                fn generate_random_dna(&self) -> u64 {
                    let mut rand_source = RandomnessSource::new();
                    let dna_digits = self.dna_digits().get();
                    let max_dna_value = u64::pow(10u64, dna_digits as u32);
                    rand_source.next_u64_in_range(0u64, max_dna_value)
                }

                #[endpoint]
                fn create_random_zombie(&self, name: ManagedBuffer) {
                    let caller = self.blockchain().get_caller();
                    require!(
                        self.owned_zombies(&caller).is_empty(),
                        "You already own a zombie"
                    );
                    let rand_dna = self.generate_random_dna();
                    self.create_zombie(caller, name, rand_dna);
                }

                #[event("newZombieEvent")]
                fn new_zombie_event(
                    &self,
                    #[indexed] zombie_id: usize,
                    name: &ManagedBuffer,
                    #[indexed] dna: u64,
                );
            }
        "storage.rs": |
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            use crate::zombie::Zombie;

            #[multiversx_sc::module]
            pub trait Storage {
                #[storage_mapper("dnaDigits")]
                fn dna_digits(&self) -> SingleValueMapper<u8>;

                #[storage_mapper("zombieLastIndex")]
                fn zombie_last_index(&self) -> SingleValueMapper<usize>;

                #[view]
                #[storage_mapper("zombies")]
                fn zombies(&self, id: &usize) -> SingleValueMapper<Zombie<Self::Api>>;

                #[view]
                #[storage_mapper("zombieOwner")]
                fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("zombieOwner")]
                fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("cryptoKittiesScAddress")]
                fn crypto_kitties_sc_address(&self) -> SingleValueMapper<ManagedAddress>;

                #[storage_mapper("ownedZombies")]
                fn owned_zombies(&self, owner: &ManagedAddress) -> UnorderedSetMapper<usize>;

                #[view]
                #[storage_mapper("cooldownTime")]
                fn cooldown_time(&self) -> SingleValueMapper<u64>;
            }
        "lib.rs": |
            #![no_std]

            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            mod storage;
            mod zombie;
            mod zombie_factory;
            mod zombie_feeding;

            #[multiversx_sc::contract]
            pub trait ZombiesContract:
                zombie_factory::ZombieFactory
                + zombie_feeding::ZombieFeeding
                + storage::Storage
            {
                #[init]
                fn init(&self) {
                    self.dna_digits().set(16u8);
                    self.zombie_last_index().set(1usize);
                    self.cooldown_time().set(86400u64);
                }

                #[upgrade]
                fn upgrade(&self) {}

                #[only_owner]
                #[endpoint]
                fn set_crypto_kitties_sc_address(&self, address: ManagedAddress) {
                    self.crypto_kitties_sc_address().set(address);
                }
            }
    answer: |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie_factory};
        use crypto_kitties_proxy::Kitty;

        mod crypto_kitties_proxy {
            multiversx_sc::imports!();
            multiversx_sc::derive_imports!();

            #[type_abi]
            #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
            pub struct Kitty {
                pub is_gestating: bool,
                pub is_ready: bool,
                pub cooldown_index: u64,
                pub next_action_at: u64,
                pub siring_with_id: u64,
                pub birth_time: u64,
                pub matron_id: u64,
                pub sire_id: u64,
                pub generation: u64,
                pub genes: u64,
            }

            #[multiversx_sc::proxy]
            pub trait CryptoKitties {
                #[endpoint]
                fn get_kitty(&self, id: usize) -> Kitty;
            }
        }

        #[multiversx_sc::module]
        pub trait ZombieFeeding:
            storage::Storage
            + zombie_factory::ZombieFactory
        {
            fn feed_and_multiply(&self, zombie_id: usize, target_dna: u64, species: ManagedBuffer) {
                let caller = self.blockchain().get_caller();
                require!(
                    caller == self.zombie_owner(&zombie_id).get(),
                    "Only the owner of the zombie can perform this operation"
                );
                require!(self.is_ready(zombie_id), "Zombie is not ready");
                let my_zombie = self.zombies(&zombie_id).get();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                let verified_target_dna = target_dna % max_dna_value;
                let mut new_dna = (my_zombie.dna + verified_target_dna) / 2;
                if species == ManagedBuffer::from(b"kitty") {
                    new_dna = new_dna - new_dna % 100 + 99;
                }
                self.create_zombie(caller, ManagedBuffer::from(b"NoName"), new_dna);
                self.trigger_cooldown(zombie_id);
            }

            fn trigger_cooldown(&self, zombie_id: usize) {
                let cooldown_time = self.cooldown_time().get();
                self.zombies(&zombie_id).update(|my_zombie| {
                    my_zombie.ready_time = self.blockchain().get_block_timestamp() + cooldown_time
                });
            }

            #[view]
            fn is_ready(&self, zombie_id: usize) -> bool {
                let my_zombie = self.zombies(&zombie_id).get();
                my_zombie.ready_time <= self.blockchain().get_block_timestamp()
            }

            #[callback]
            fn get_kitty_callback(
                &self,
                #[call_result] result: ManagedAsyncCallResult<Kitty>,
                zombie_id: usize,
            ) {
                match result {
                    ManagedAsyncCallResult::Ok(kitty) => {
                        let kitty_dna = kitty.genes;
                        self.feed_and_multiply(zombie_id, kitty_dna, ManagedBuffer::from(b"kitty"));
                    },
                    ManagedAsyncCallResult::Err(_) => {},
                }
            }

            #[endpoint]
            fn feed_on_kitty(
                &self,
                zombie_id: usize,
                kitty_id: usize,
            ) {
            let crypto_kitties_sc_address = self.crypto_kitties_sc_address().get();
                self.kitty_proxy(crypto_kitties_sc_address)
                    .get_kitty(kitty_id)
                    .async_call()
                    .with_callback(self.callbacks().get_kitty_callback(zombie_id))
                    .call_and_exit();
            }

            #[proxy]
            fn kitty_proxy(&self, to: ManagedAddress) -> crypto_kitties_proxy::Proxy<Self::Api>;
        }
---

Now let's modify `feed_and_multiply` to take our cooldown timer into account.

Looking back at this function, you can see we made it an endpoint available to everyone in the last lesson. An important security practice is to examine all your endpoints and who has access to them, and try to think of ways users might abuse them. Remember — unless these functions have a modifier like `#[only_owner]`, any user can call them and pass them any data they want to.

Re-examining this particular function, the user could call the function directly and pass in any `target_dna` or `species` they want to. This doesn't seem very game-like — we want them to follow our rules!

On closer inspection, this function only needs to be called by `feed_on_kitty()`, so the easiest way to prevent these exploits is to remove the `#[endpoint]` annotation

## Put it to the test

1. Currently `feed_and_multiply` is an endpoint with open access to everyone. Let's make it a simple function by removing the `#[endpoint]` annotation so that the contract is more secure. We don't want users to be able to call this function with any DNA they want.

2. Let's make `feed_and_multiply` take our `cooldown_time` into account. First, before we look up `my_zombie`, let's add a `require` statement that checks `is_ready()` and throws an error "Zombie is not ready" if it is `false`. This way the user can only execute this function if a zombie's cooldown time is over.

3. At the end of the function let's call `trigger_cooldown(zombie_id)` so that feeding triggers the zombie's cooldown time.
