---
title: Bonus - Batch Minting
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
        "AliensVsZmb.sol": |
            pragma solidity ^0.4.25;

            import "./erc721x.sol";

            import "./safemath.sol";

            import "./dna.sol";

            import "./erc721xtoken.sol";

            import "./ownable.sol";


            contract AliensVsZmb is ERC721X, ERC721XToken, Ownable {

                using SafeMath for uint256;

                using DNA for uint256;

                mapping(uint256 => uint256) public tokenIdToDNA;

                event TokenClaimed(uint256 indexed tokenId, address claimer, uint256 amount);

                function BatchMintToken (uint256[] _tokenIds, uint256[] _tokenDNAs) external onlyOwnerOf
                  {
                    //start here
                  }

                function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) internal isOperatorOrOwner(_from) {
                        require(tokenType[_tokenId] == FT);
                        require(_to != address(0), "Invalid `to` address");

                        if (isLimitedEdition(_tokenId) || _from != address(this)) {
                            require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                            _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                        }

                        _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                        emit TransferWithQuantity(_from, _to, _tokenId, _amount);
                }



                function claimTokenNFT(uint256 _tokenId, address _to) external onlyOwnerOf {

                    tokenOwner[_tokenId] = _to;


                    _claimToken(_tokenId, _to, 1);


                    emit Transfer(address(this), _to, _tokenId);
                }

                function claimToken(uint256 _tokenId, address _to, uint256 _amount) external onlyOwnerOf {  

                    _claimToken(_tokenId, _to, _amount);

                    }

                function _claimToken(uint256 _tokenId, address _to, uint256 _amount) internal {
                    require(exists(_tokenId), "TokenID has not been minted");
                    if (isLimitedEdition(_tokenId)) {
                        _updateTokenBalance(address(this), _tokenId, _amount, ObjectLib.Operations.SUB);
                    }
                    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                    emit TokenClaimed(_tokenId, _to, _amount);
                }


                function isLimitedEdition(uint256 _tokenId) public view returns (bool) {
                    return tokenIdToDNA[_tokenId].totalSupply() != 0;
                }

                modifier onlyOwnerOf() {
                    require(msg.sender == owner);
                    _;
                }

                function mintToken(uint256 _tokenId, uint256 _tokenDNA) onlyOwnerOf {

                    uint256 supply = _tokenDNA.totalSupply();

                    if (supply == 1) {
                        _mint(_tokenId, address(this));
                    } else {
                        _mint(_tokenId, address(this), supply);
                    }

                    tokenIdToDNA[_tokenId] = _tokenDNA;

                }

                function name() external view returns (string) {
                    return "AliensVsZmbCard";
                }

                function symbol() external view returns (string) {
                    return "AVZ";
                }
            }

        "erc721x.sol": |

            pragma solidity ^0.4.25;
            contract ERC721X {
                function implementsERC721X() public pure returns (bool);
                function ownerOf(uint256 _tokenId) public view returns (address _owner);
                function balanceOf(address owner) public view returns (uint256);
                function balanceOf(address owner, uint256 tokenId) public view returns (uint256);
                function tokensOwned(address owner) public view returns (uint256[], uint256[]);

                function transfer(address to, uint256 tokenId, uint256 quantity) public;
                function transferFrom(address from, address to, uint256 tokenId, uint256 quantity) public;

                // Fungible Safe Transfer From
                function safeTransferFrom(address from, address to, uint256 tokenId, uint256 _amount) public;
                function safeTransferFrom(address from, address to, uint256 tokenId, uint256 _amount, bytes data) public;

                // Batch Safe Transfer From
                function safeBatchTransferFrom(address _from, address _to, uint256[] tokenIds, uint256[] _amounts, bytes _data) public;

                function name() external view returns (string);
                function symbol() external view returns (string);

                // Required Events
                event TransferWithQuantity(address indexed from, address indexed to, uint256 indexed tokenId, uint256 quantity);
                event TransferToken(address indexed from, address indexed to, uint256 indexed tokenId, uint256 quantity);
                event BatchTransfer(address indexed from, address indexed to, uint256[] tokenTypes, uint256[] amounts);
            }

        "safemath.sol": |
          pragma solidity ^0.4.25;

          /**
           * @title SafeMath
           * @dev Math operations with safety checks that throw on error
          */
          library SafeMath {

              /**
              * @dev Multiplies two numbers, throws on overflow.
              */
           function mul(uint256 a, uint256 b) internal pure returns (uint256) {
                  if (a == 0) {
                      return 0;
                  }
                  uint256 c = a * b;
                  assert(c / a == b);
                  return c;
              }

              /**
              * @dev Integer division of two numbers, truncating the quotient.
              */
              function div(uint256 a, uint256 b) internal pure returns (uint256) {
                  // assert(b > 0); // Solidity automatically throws when dividing by 0
                  uint256 c = a / b;
                  // assert(a == b * c + a % b); // There is no case in which this doesn't hold
                  return c;
              }

              /**
              * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
              */
              function sub(uint256 a, uint256 b) internal pure returns (uint256) {
                 assert(b <= a);
                  return a - b;
              }

              /**
              * @dev Adds two numbers, throws on overflow.
              */
              function add(uint256 a, uint256 b) internal pure returns (uint256) {
                  uint256 c = a + b;
                 assert(c >= a);
                  return c;
              }
          }

        "dna.sol": |
            pragma solidity ^0.4.25;

            library DNA {
                enum Trait {
                    COSMETIC_TYPE, //let's suppose we have COMMON and ANIMATED cards
                    SERIES_TOTAL,  //the maximum supply
                    EDITION //could be general, officer, etc
                }

                function get2Bytes(uint256 cardDNA, Trait i) internal pure returns (bytes2) {
                    return bytes2(cardDNA >> uint8(i)*16);
                }

                function totalSupply(uint256 cardDNA) internal pure returns (uint256) {
                    return uint256(get2Bytes(cardDNA, Trait.SERIES_TOTAL));
                }

            }

        "erc721xtoken.sol": |
            pragma solidity ^0.4.25;


            import "./../../Interfaces/ERC721X.sol";

            import "./../../Interfaces/ERC721XReceiver.sol";
            import "./ERC721XTokenNFT.sol";

            import "./openzeppelin-solidity/contracts/AddressUtils.sol";
            import "./../../Libraries/ObjectsLib.sol";


            // Additional features over NFT token that is compatible with batch transfers
            contract ERC721XToken is ERC721X, ERC721XTokenNFT {

                using ObjectLib for ObjectLib.Operations;
                using AddressUtils for address;

                bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
                bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

                event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


                modifier isOperatorOrOwner(address _from) {
                    require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                    _;
                }

                function implementsERC721X() public pure returns (bool) {
                    return true;
                }

                /**
                * @dev transfer objects from different tokenIds to specified address
                * @param _from The address to BatchTransfer objects from.
                * @param _to The address to batchTransfer objects to.
                * @param _tokenIds Array of tokenIds to update balance of
                * @param _amounts Array of amount of object per type to be transferred.
                * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
                */
                function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                    internal
                    isOperatorOrOwner(_from)
                {

                    // Requirements
                    require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                    require(_to != address(0), "Invalid recipient");

                    if (tokenType[_tokenIds[0]] == NFT) {
                        tokenOwner[_tokenIds[0]] = _to;
                        emit Transfer(_from, _to, _tokenIds[0]);
                    }

                    // Load first bin and index where the object balance exists
                    (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                    // Balance for current bin in memory (initialized with first transfer)
                    // Written with bad library syntax instead of as below to bypass stack limit error
                    uint256 balFrom = ObjectLib.updateTokenBalance(
                        packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                    );
                    uint256 balTo = ObjectLib.updateTokenBalance(
                        packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                    );

                    // Number of transfers to execute
                    uint256 nTransfer = _tokenIds.length;

                    // Last bin updated
                    uint256 lastBin = bin;

                    for (uint256 i = 1; i < nTransfer; i++) {
                        // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                        if (tokenType[_tokenIds[i]] == NFT) {
                            tokenOwner[_tokenIds[i]] = _to;
                            emit Transfer(_from, _to, _tokenIds[i]);
                        }
                        (bin, index) = _tokenIds[i].getTokenBinIndex();

                        // If new bin
                        if (bin != lastBin) {
                            // Update storage balance of previous bin
                            packedTokenBalance[_from][lastBin] = balFrom;
                            packedTokenBalance[_to][lastBin] = balTo;

                            // Load current bin balance in memory
                            balFrom = packedTokenBalance[_from][bin];
                            balTo = packedTokenBalance[_to][bin];

                            // Bin will be the most recent bin
                            lastBin = bin;
                        }

                        // Update memory balance
                        balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                        balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                    }

                    // Update storage of the last bin visited
                    packedTokenBalance[_from][bin] = balFrom;
                    packedTokenBalance[_to][bin] = balTo;

                    // Emit batchTransfer event
                    emit BatchTransfer(_from, _to, _tokenIds, _amounts);
                }

                function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                    // Batch Transfering
                    _batchTransferFrom(_from, _to, _tokenIds, _amounts);
                }

                /**
                * @dev transfer objects from different tokenIds to specified address
                * @param _from The address to BatchTransfer objects from.
                * @param _to The address to batchTransfer objects to.
                * @param _tokenIds Array of tokenIds to update balance of
                * @param _amounts Array of amount of object per type to be transferred.
                * @param _data Data to pass to onERC721XReceived() function if recipient is contract
                * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
                */
                function safeBatchTransferFrom(
                    address _from,
                    address _to,
                    uint256[] _tokenIds,
                    uint256[] _amounts,
                    bytes _data
                )
                    public
                {

                    // Batch Transfering
                    _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                    // Pass data if recipient is contract
                    if (_to.isContract()) {
                        bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                            msg.sender, _from, _tokenIds, _amounts, _data
                        );
                        require(retval == ERC721X_BATCH_RECEIVE_SIG);
                    }
                }

                function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                    _transferFrom(msg.sender, _to, _tokenId, _amount);
                }

                function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                    _transferFrom(_from, _to, _tokenId, _amount);
                }

                function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                    internal
                    isOperatorOrOwner(_from)
                {
                    require(tokenType[_tokenId] == FT);
                    require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                    require(_to != address(0), "Invalid to address");

                    _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                    emit TransferWithQuantity(_from, _to, _tokenId, _amount);
                }

                function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                    safeTransferFrom(_from, _to, _tokenId, _amount, "");
                }

                function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                    _transferFrom(_from, _to, _tokenId, _amount);
                    require(
                        checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                        "Sent to a contract which is not an ERC721X receiver"
                    );
                }

                function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                    // If the token doesn't exist, add it to the tokens array
                    if (!exists(_tokenId)) {
                        tokenType[_tokenId] = FT;
                        allTokens.push(_tokenId);
                    } else {
                        // if the token exists, it must be a FT
                        require(tokenType[_tokenId] == FT, "Not a FT");
                    }

                    _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.REPLACE);
                    emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
                }


                function checkAndCallSafeTransfer(
                    address _from,
                    address _to,
                    uint256 _tokenId,
                    uint256 _amount,
                    bytes _data
                )
                    internal
                    returns (bool)
                {
                    if (!_to.isContract()) {
                        return true;
                    }

                    bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                        msg.sender, _from, _tokenId, _amount, _data);
                    return(retval == ERC721X_RECEIVED);
                }

            }
        "ownable.sol": |
            pragma solidity ^0.4.25;

            /**
            * @title Ownable
            * @dev The Ownable contract has an owner address, and provides basic authorization control
            * functions, this simplifies the implementation of "user permissions".
            */
            contract Ownable {
            address public owner;

            event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

            /**
            * @dev The Ownable constructor sets the original `owner` of the contract to the sender
            * account.
            */
            function Ownable() public {
                owner = msg.sender;
            }


            /**
            * @dev Throws if called by any account other than the owner.
            */
            modifier onlyOwnerOf() {
                require(msg.sender == owner);
                _;
            }


            /**
            * @dev Allows the current owner to transfer control of the contract to a newOwner.
            * @param newOwner The address to transfer ownership to.
            */
            function transferOwnership(address newOwner) public onlyOwnerOf {
                require(newOwner != address(0));
                OwnershipTransferred(owner, newOwner);
                owner = newOwner;
            }

            }


    answer: >

        pragma solidity ^0.4.25;

        import "./erc721x.sol";

        import "./safemath.sol";

        import "./dna.sol";

        import "./erc721xtoken.sol";

        import "./ownable.sol";


        contract AliensVsZmb is ERC721X, ERC721XToken, Ownable {

            using SafeMath for uint256;

            using DNA for uint256;

            mapping(uint256 => uint256) public tokenIdToDNA;

            event TokenClaimed(uint256 indexed tokenId, address claimer, uint256 amount);

            function BatchMintToken (uint256[] _tokenIds, uint256[] _tokenDNAs) external onlyOwnerOf {
              for(uint256 i = 0; i<_tokenIds.length; i++) {
                mintToken(_tokenIds[i], _tokenDNAs[i]);
              }

            }

            function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) internal isOperatorOrOwner(_from) {
                    require(tokenType[_tokenId] == FT);
                    require(_to != address(0), "Invalid `to` address");

                    if (isLimitedEdition(_tokenId) || _from != address(this)) {
                        require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                        _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                    }

                    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                    emit TransferWithQuantity(_from, _to, _tokenId, _amount);
            }

            function claimTokenNFT(uint256 _tokenId, address _to) external onlyOwnerOf {

                tokenOwner[_tokenId] = _to;


                _claimToken(_tokenId, _to, 1);


                emit Transfer(address(this), _to, _tokenId);
            }

            function claimToken(uint256 _tokenId, address _to, uint256 _amount) external onlyOwnerOf {  

                _claimToken(_tokenId, _to, _amount);

                }

            function _claimToken(uint256 _tokenId, address _to, uint256 _amount) internal {
                require(exists(_tokenId), "TokenID has not been minted");
                if (isLimitedEdition(_tokenId)) {
                    _updateTokenBalance(address(this), _tokenId, _amount, ObjectLib.Operations.SUB);
                }
                _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                emit TokenClaimed(_tokenId, _to, _amount);
            }


            function isLimitedEdition(uint256 _tokenId) public view returns (bool) {
                return tokenIdToDNA[_tokenId].totalSupply() != 0;
            }

            modifier onlyOwnerOf() {
                require(msg.sender == owner);
                 _;
            }

            function mintToken(uint256 _tokenId, uint256 _tokenDNA) onlyOwnerOf {

                uint256 supply = _tokenDNA.totalSupply();

                if (supply == 1) {
                    _mint(_tokenId, address(this));
                } else {
                    _mint(_tokenId, address(this), supply);
                }

                tokenIdToDNA[_tokenId] = _tokenDNA;

            }

            function name() external view returns (string) {
                return "AliensVsZmbCard";
            }

            function symbol() external view returns (string) {
                return "AVZ";
            }
        }

---
Let's finish off our `batchMintToken` function.

The only thing left for us to do is to iterate through each `_tokenId` in `_tokenIds` and call `mintToken`.

Here’s an example of how you would iterate through an array:

```Solidity
for (uint256 i = 0; i < _tokenIds.length; i++) {
  // do something with _tokenIds[i] and _tokenDNAs[i]
}
```


# Put it to the test

1. Add the for loop that iterates through each `_tokenId` in `_tokenIds`.
2. For each `_tokenId`, call `mintToken`. It takes two parameters `_tokenIds[i]`, `_tokenDNAs[i]`;
