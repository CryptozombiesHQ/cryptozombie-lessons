---
title: The First Test- Creating a New Zombie (cont'd)
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
    editor:
        language: javascript
        startingCode:
            "test/CryptoZombies.js": |
                const CryptoZombies = artifacts.require("CryptoZombies");
                const zombieNames = ["Zombie 1", "Zombie 2"];
                contract("CryptoZombies", (accounts) => {
                    let [alice, bob] = accounts;
                    it("should be able to create a new zombie", async () => {
                        const contractInstance = await CryptoZombies.new();
                        // start here
                    })
                })
        answer: >
            const CryptoZombies = artifacts.require("CryptoZombies");

            const zombieNames = ["Zombie 1", "Zombie 2"];

            contract("CryptoZombies", (accounts) => {
                let [alice, bob] = accounts;
                it("should be able to create a new zombie", async () => {
                    const contractInstance = await CryptoZombies.new();
                    const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
                    assert.equal(result.receipt.status, true);
                    assert.equal(result.logs[0].args.name,zombieNames[0]);
                })
            })
---
Now that we've got our ducks -ahem zombies- in row, let's move forward to the next phase... 🧟🦆‍🧟🦆🧟🦆‍🧟🦆🧟🦆‍🧟🦆

## 2. Act

We've reached the part where we're going to be calling the function that creates a new zombie for Alice- `createRandomZombie`.

But there's a slight problem- how can we make it so the method "knows" who calls it? Another way to put it would be- how can we make sure Alice (and not Bob) is going to be the owner of this new zombie?🧐

Well... the problem is solved with the _contract abstraction_. One of the features of _Truffle_ is that it wraps the original _Solidity_ implementation and lets us specify the address that makes the function call by passing that address as an argument.

The following calls `createRandomZombie` and makes sure `msg.sender` is set to Alice's address:

```javascript
const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
```

Now I have a quick question for you: do you know what gets stored in `result`?

Well, let me explain.

#### Logs and Events

Once we specified the contract we wanted to test using `artifacts.require`, _Truffle_  automatically provides the logs generated by our smart contract. What this means is that we can now retrieve the `name` of Alice's newly created zombie using something like this: `result.logs[0].args.name`. In a similar fashion, we can get the `id` and the `_dna`.

Besides these bits of information, `result` is going to be giving us several other useful details about the transaction:

- `result.tx`: the transaction hash
- `result.receipt`: an object containing the transaction receipt. If `result.receipt.status` is equal to ` true` it means that the transaction was successful. Otherwise, it means that the transaction failed.

>Note: Note that logs can also be used as a much cheaper option to store data. The downside is that they can't be accessed from within the smart contract itself.

## 3. Assert

In this chapter we will be using the built-in assertion module which comes with a set of assertion functions such as `equal()` and `deepEqual()`. Simply put, these functions check the condition and `throw` an error if the result is not as expected. Since we will be comparing simple values, we are going to be running `assert.equal()`.

# Put it to the test

Let's finish off our first test.

1.  Declare a `const` named `result`, and set it equal to the result of `contractInstance.createRandomZombie` with the zombie's name and the owner as arguments.

2.  Once we have the `result`, call `assert.equal` with two arguments- `result.receipt.status` and `true`.

If the above condition is true, we can assume that our test has been passed. Just to be safe, let's add in one more check while we're here.

3.  In the next line, check if `result.logs[0].args.name` equals to `zombieNames[0]`. Use `assert.equal`, just like we did above.

Now, it is time to run `truffle test` and see if our first test passes. The way this works is that _Truffle_ will just inspect the _"test"_ directory and execute the files it finds there.

Actually, we've gone ahead and did that for you. The output should look something like this:

```bash
Contract: CryptoZombies
    ✓ should be able to create a new zombie (323ms)


  1 passing (768ms)
```

This concludes your very first test - well done! There are several more to come, so let's get going on the next lesson...
