---
title: Making a trait implementation!
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: rust
    startingCode:
      "kitty_obj.rs": |
        use multiversx_sc::derive_imports::*;
            
        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Kitty {
            pub genes: KittyGenes,
            pub birth_time: u64,   // timestamp
            pub cooldown_end: u64, // timestamp, used for pregnancy timer and siring cooldown
            pub matron_id: u32,
            pub sire_id: u32,
            pub siring_with_id: u32, // for pregnant cats, 0 otherwise
            pub nr_children: u16,    // cooldown period increases exponentially with every breeding/siring
            pub generation: u16,     // max(sire_gen, matron_gen) + 1. Generation also influences cooldown.
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct KittyGenes {
            pub fur_color: Color,
            pub eye_color: Color,
            pub meow_power: u8, // the higher the value, the louder the cat
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Color {
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }

        // start here
      "kitty_ownership_proxy.rs": |
        // Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

        ////////////////////////////////////////////////////
        ////////////////// AUTO-GENERATED //////////////////
        ////////////////////////////////////////////////////

        #![allow(dead_code)]
        #![allow(clippy::all)]

        use multiversx_sc::proxy_imports::*;

        pub struct KittyOwnershipProxy;

        impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for KittyOwnershipProxy
        where
            Env: TxEnv,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            type TxProxyMethods = KittyOwnershipProxyMethods<Env, From, To, Gas>;

            fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
                KittyOwnershipProxyMethods { wrapped_tx: tx }
            }
        }

        pub struct KittyOwnershipProxyMethods<Env, From, To, Gas>
        where
            Env: TxEnv,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
        }

        #[rustfmt::skip]
        impl<Env, From, Gas> KittyOwnershipProxyMethods<Env, From, (), Gas>
        where
            Env: TxEnv,
            Env::Api: VMApi,
            From: TxFrom<Env>,
            Gas: TxGas<Env>,
        {
            pub fn init<
                Arg0: ProxyArg<BigUint<Env::Api>>,
                Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
                Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
            >(
                self,
                birth_fee: Arg0,
                opt_gene_science_contract_address: Arg1,
                opt_kitty_auction_contract_address: Arg2,
            ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_deploy()
                    .argument(&birth_fee)
                    .argument(&opt_gene_science_contract_address)
                    .argument(&opt_kitty_auction_contract_address)
                    .original_result()
            }
        }

        #[rustfmt::skip]
        impl<Env, From, To, Gas> KittyOwnershipProxyMethods<Env, From, To, Gas>
        where
            Env: TxEnv,
            Env::Api: VMApi,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            pub fn set_gene_science_contract_address_endpoint<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("setGeneScienceContractAddress")
                    .argument(&address)
                    .original_result()
            }

            pub fn set_kitty_auction_contract_address_endpoint<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("setKittyAuctionContractAddress")
                    .argument(&address)
                    .original_result()
            }

            pub fn claim(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("claim")
                    .original_result()
            }

            pub fn total_supply(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("totalSupply")
                    .original_result()
            }

            pub fn balance_of<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("balanceOf")
                    .argument(&address)
                    .original_result()
            }

            pub fn owner_of<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("ownerOf")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn approve<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                to: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approve")
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn transfer<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                to: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("transfer")
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn transfer_from<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<ManagedAddress<Env::Api>>,
                Arg2: ProxyArg<u32>,
            >(
                self,
                from: Arg0,
                to: Arg1,
                kitty_id: Arg2,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("transfer_from")
                    .argument(&from)
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn tokens_of_owner<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("tokensOfOwner")
                    .argument(&address)
                    .original_result()
            }

            pub fn allow_auctioning<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                by: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("allowAuctioning")
                    .argument(&by)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn approve_siring_and_return_kitty<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<ManagedAddress<Env::Api>>,
                Arg2: ProxyArg<u32>,
            >(
                self,
                approved_address: Arg0,
                kitty_owner: Arg1,
                kitty_id: Arg2,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approveSiringAndReturnKitty")
                    .argument(&approved_address)
                    .argument(&kitty_owner)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn create_gen_zero_kitty(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("createGenZeroKitty")
                    .original_result()
            }

            pub fn get_kitty_by_id_endpoint<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, crate::kitty_obj::Kitty> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("getKittyById")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn is_ready_to_breed<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("isReadyToBreed")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn is_pregnant<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("isPregnant")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn can_breed_with<
                Arg0: ProxyArg<u32>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
                sire_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("canBreedWith")
                    .argument(&matron_id)
                    .argument(&sire_id)
                    .original_result()
            }

            pub fn approve_siring<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                address: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approveSiring")
                    .argument(&address)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn breed_with<
                Arg0: ProxyArg<u32>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
                sire_id: Arg1,
            ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
                self.wrapped_tx
                    .raw_call("breedWith")
                    .argument(&matron_id)
                    .argument(&sire_id)
                    .original_result()
            }

            pub fn give_birth<
                Arg0: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("giveBirth")
                    .argument(&matron_id)
                    .original_result()
            }

            pub fn birth_fee(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("birthFee")
                    .original_result()
            }
        }
      "zombie_feeding.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie_factory};

        #[multiversx_sc::module]
        pub trait ZombieFeeding:
            storage::Storage
            + zombie_factory::ZombieFactory
        {
            #[endpoint]
            fn feed_and_multiply(&self, zombie_id: usize, target_dna: u64) {
                let caller = self.blockchain().get_caller();
                require!(
                    caller == self.zombie_owner(&zombie_id).get(),
                    "Only the owner of the zombie can perform this operation"
                );
                let my_zombie = self.zombies(&zombie_id).get();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                let verified_target_dna = target_dna % max_dna_value;
                let new_dna = (my_zombie.dna + verified_target_dna) / 2;
                self.create_zombie(caller, ManagedBuffer::from(b"NoName"), new_dna);
            }
        }
      "zombie.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Zombie<M: ManagedTypeApi> {
            pub name: ManagedBuffer<M>,
            pub dna: u64,
        }
      "zombie_factory.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie::Zombie};

        #[multiversx_sc::module]
        pub trait ZombieFactory: storage::Storage {
            fn create_zombie(&self, owner: ManagedAddress, name: ManagedBuffer, dna: u64) {
                self.zombie_last_index().update(|id| {
                    self.new_zombie_event(*id, &name, dna);
                    self.zombies(id).set(Zombie { name, dna });
                    self.owned_zombies(&owner).insert(*id);
                    self.zombie_owner(id).set(owner);
                    *id += 1;
                });
            }

            #[view]
            fn generate_random_dna(&self) -> u64 {
                let mut rand_source = RandomnessSource::new();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                rand_source.next_u64_in_range(0u64, max_dna_value)
            }

            #[endpoint]
            fn create_random_zombie(&self, name: ManagedBuffer) {
                let caller = self.blockchain().get_caller();
                require!(
                    self.owned_zombies(&caller).is_empty(),
                    "You already own a zombie"
                );
                let rand_dna = self.generate_random_dna();
                self.create_zombie(caller, name, rand_dna);
            }

            #[event("newZombieEvent")]
            fn new_zombie_event(
                &self,
                #[indexed] zombie_id: usize,
                name: &ManagedBuffer,
                #[indexed] dna: u64,
            );
        }
      "storage.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::zombie::Zombie;

        #[multiversx_sc::module]
        pub trait Storage {
            #[storage_mapper("dnaDigits")]
            fn dna_digits(&self) -> SingleValueMapper<u8>;

            #[storage_mapper("zombieLastIndex")]
            fn zombie_last_index(&self) -> SingleValueMapper<usize>;

            #[view]
            #[storage_mapper("zombies")]
            fn zombies(&self, id: &usize) -> SingleValueMapper<Zombie<Self::Api>>;

            #[storage_mapper("zombieOwner")]
            fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

            #[storage_mapper("ownedZombies")]
            fn owned_zombies(&self, owner: &ManagedAddress) -> UnorderedSetMapper<usize>;
        }
      "lib.rs": |
        #![no_std]

        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        mod storage;
        mod zombie;
        mod zombie_factory;
        mod zombie_feeding;

        #[multiversx_sc::contract]
        pub trait ZombiesContract:
            zombie_factory::ZombieFactory
            + zombie_feeding::ZombieFeeding
            + storage::Storage
        {
            #[init]
            fn init(&self) {
                self.dna_digits().set(16u8);
                self.zombie_last_index().set(1usize);
            }

            #[upgrade]
            fn upgrade(&self) {}
        }
    answer: |
        use multiversx_sc::derive_imports::*;
            
        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Kitty {
            pub genes: KittyGenes,
            pub birth_time: u64,   // timestamp
            pub cooldown_end: u64, // timestamp, used for pregnancy timer and siring cooldown
            pub matron_id: u32,
            pub sire_id: u32,
            pub siring_with_id: u32, // for pregnant cats, 0 otherwise
            pub nr_children: u16,    // cooldown period increases exponentially with every breeding/siring
            pub generation: u16,     // max(sire_gen, matron_gen) + 1. Generation also influences cooldown.
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct KittyGenes {
            pub fur_color: Color,
            pub eye_color: Color,
            pub meow_power: u8, // the higher the value, the louder the cat
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Color {
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }

        impl Color {
            pub fn as_u64(&self) -> u64 {
                ((self.r.to_be() as u64) << 8 | self.r.to_be() as u64) << 8 | self.r.to_be() as u64
            }
        }

        impl KittyGenes {
            pub fn get_as_u64(&self) -> u64 {
                (self.fur_color.as_u64() << 24 | self.eye_color.as_u64()) << 8
                    | self.meow_power.to_be() as u64
            }
        }
---

So, we got the Crypto Kitties inside our zombies contract, but as we see, the format of the genes is a bit different than what we need. The issue we face is that the kitty genes contain 3 elements: `fur_color`, `eye_color` and `meow_power`, while we just need an element of type u64.

In our last task we imported the `KittiesGenes` and `Color` structs from the kitties contract. Now we new need to make an implementation on these structures allowing us to use the provided elements and return us some genes that our zombies can devour!

## Making an implementation for a struct

We need to but all the component bytes head to head to build an `u64`. We can accomplish that by converting every `Color` to a Big Endian byte interpretation and shifting it to the left with `<<`.
After that we do the same with `KittyGenes`.

Implementing on a struct is easy and straigth forward. Take the following example:

```rust
#[multiversx_sc::contract]
pub struct MyStruct {
    pub a: u8
    pub b: u8
    pub c: u8
}


impl MyStruct {
    pub fn as_u64(&self) -> u64 {
        (self.a.to_be() << 8 | self.b.to_be()) << 8 | self.c.to_be()
    }
}
```
What we did was to take each element that builds `MyStruct`, cast it to the Big Endian byte interpretation, shift it the size of the next element to the left, and finally, make a logic OR operation to add the next element after it, repeating this for everything containing in `MyStruct`.

# Put it to the test

1. Make an implementation on the `Color` struct, putting all 3 colors into an `u64`.

2. Make an implementation on the `KittyGenes` struct, putting all the containing elements into a single `u64`. Remember to use the `as_u64` function of `Color`, that we implemented before. Lets call this function `get_as_u64`.
> Note: When shifting `fur_color` we will need to make space for a second `Color`, so we will shift with 24 ( 8 bytes * 3 elements in `Color` = 24 bytes to shift)
> When shifting the element containing `fur_color`, `eye_color` we will need to make space for `meow_power` which is of size `u8`, so we will shift by 8.
