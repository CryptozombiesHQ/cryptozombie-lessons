---
title: What Do Zombies Eat?
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: rust
    startingCode:
      "kitty_obj.rs": |
        use multiversx_sc::derive_imports::*;
            
            // start here
      "kitty_ownership_proxy.rs": |
        // Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

        ////////////////////////////////////////////////////
        ////////////////// AUTO-GENERATED //////////////////
        ////////////////////////////////////////////////////

        #![allow(dead_code)]
        #![allow(clippy::all)]

        use multiversx_sc::proxy_imports::*;

        pub struct KittyOwnershipProxy;

        impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for KittyOwnershipProxy
        where
            Env: TxEnv,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            type TxProxyMethods = KittyOwnershipProxyMethods<Env, From, To, Gas>;

            fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
                KittyOwnershipProxyMethods { wrapped_tx: tx }
            }
        }

        pub struct KittyOwnershipProxyMethods<Env, From, To, Gas>
        where
            Env: TxEnv,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
        }

        #[rustfmt::skip]
        impl<Env, From, Gas> KittyOwnershipProxyMethods<Env, From, (), Gas>
        where
            Env: TxEnv,
            Env::Api: VMApi,
            From: TxFrom<Env>,
            Gas: TxGas<Env>,
        {
            pub fn init<
                Arg0: ProxyArg<BigUint<Env::Api>>,
                Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
                Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
            >(
                self,
                birth_fee: Arg0,
                opt_gene_science_contract_address: Arg1,
                opt_kitty_auction_contract_address: Arg2,
            ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_deploy()
                    .argument(&birth_fee)
                    .argument(&opt_gene_science_contract_address)
                    .argument(&opt_kitty_auction_contract_address)
                    .original_result()
            }
        }

        #[rustfmt::skip]
        impl<Env, From, To, Gas> KittyOwnershipProxyMethods<Env, From, To, Gas>
        where
            Env: TxEnv,
            Env::Api: VMApi,
            From: TxFrom<Env>,
            To: TxTo<Env>,
            Gas: TxGas<Env>,
        {
            pub fn set_gene_science_contract_address_endpoint<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("setGeneScienceContractAddress")
                    .argument(&address)
                    .original_result()
            }

            pub fn set_kitty_auction_contract_address_endpoint<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("setKittyAuctionContractAddress")
                    .argument(&address)
                    .original_result()
            }

            pub fn claim(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("claim")
                    .original_result()
            }

            pub fn total_supply(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("totalSupply")
                    .original_result()
            }

            pub fn balance_of<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("balanceOf")
                    .argument(&address)
                    .original_result()
            }

            pub fn owner_of<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("ownerOf")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn approve<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                to: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approve")
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn transfer<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                to: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("transfer")
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn transfer_from<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<ManagedAddress<Env::Api>>,
                Arg2: ProxyArg<u32>,
            >(
                self,
                from: Arg0,
                to: Arg1,
                kitty_id: Arg2,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("transfer_from")
                    .argument(&from)
                    .argument(&to)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn tokens_of_owner<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
            >(
                self,
                address: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u32>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("tokensOfOwner")
                    .argument(&address)
                    .original_result()
            }

            pub fn allow_auctioning<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                by: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("allowAuctioning")
                    .argument(&by)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn approve_siring_and_return_kitty<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<ManagedAddress<Env::Api>>,
                Arg2: ProxyArg<u32>,
            >(
                self,
                approved_address: Arg0,
                kitty_owner: Arg1,
                kitty_id: Arg2,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approveSiringAndReturnKitty")
                    .argument(&approved_address)
                    .argument(&kitty_owner)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn create_gen_zero_kitty(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("createGenZeroKitty")
                    .original_result()
            }

            pub fn get_kitty_by_id_endpoint<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, crate::kitty_obj::Kitty> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("getKittyById")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn is_ready_to_breed<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("isReadyToBreed")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn is_pregnant<
                Arg0: ProxyArg<u32>,
            >(
                self,
                kitty_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("isPregnant")
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn can_breed_with<
                Arg0: ProxyArg<u32>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
                sire_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("canBreedWith")
                    .argument(&matron_id)
                    .argument(&sire_id)
                    .original_result()
            }

            pub fn approve_siring<
                Arg0: ProxyArg<ManagedAddress<Env::Api>>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                address: Arg0,
                kitty_id: Arg1,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("approveSiring")
                    .argument(&address)
                    .argument(&kitty_id)
                    .original_result()
            }

            pub fn breed_with<
                Arg0: ProxyArg<u32>,
                Arg1: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
                sire_id: Arg1,
            ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
                self.wrapped_tx
                    .raw_call("breedWith")
                    .argument(&matron_id)
                    .argument(&sire_id)
                    .original_result()
            }

            pub fn give_birth<
                Arg0: ProxyArg<u32>,
            >(
                self,
                matron_id: Arg0,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("giveBirth")
                    .argument(&matron_id)
                    .original_result()
            }

            pub fn birth_fee(
                self,
            ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
                self.wrapped_tx
                    .payment(NotPayable)
                    .raw_call("birthFee")
                    .original_result()
            }
        }
      "zombie_feeding.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie_factory};

        #[multiversx_sc::module]
        pub trait ZombieFeeding:
            storage::Storage
            + zombie_factory::ZombieFactory
        {
            #[endpoint]
            fn feed_and_multiply(&self, zombie_id: usize, target_dna: u64) {
                let caller = self.blockchain().get_caller();
                require!(
                    caller == self.zombie_owner(&zombie_id).get(),
                    "Only the owner of the zombie can perform this operation"
                );
                let my_zombie = self.zombies(&zombie_id).get();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                let verified_target_dna = target_dna % max_dna_value;
                let new_dna = (my_zombie.dna + verified_target_dna) / 2;
                self.create_zombie(caller, ManagedBuffer::from(b"NoName"), new_dna);
            }
        }
      "zombie.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Zombie<M: ManagedTypeApi> {
            pub name: ManagedBuffer<M>,
            pub dna: u64,
        }
      "zombie_factory.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::{storage, zombie::Zombie};

        #[multiversx_sc::module]
        pub trait ZombieFactory: storage::Storage {
            fn create_zombie(&self, owner: ManagedAddress, name: ManagedBuffer, dna: u64) {
                self.zombie_last_index().update(|id| {
                    self.new_zombie_event(*id, &name, dna);
                    self.zombies(id).set(Zombie { name, dna });
                    self.owned_zombies(&owner).insert(*id);
                    self.zombie_owner(id).set(owner);
                    *id += 1;
                });
            }

            #[view]
            fn generate_random_dna(&self) -> u64 {
                let mut rand_source = RandomnessSource::new();
                let dna_digits = self.dna_digits().get();
                let max_dna_value = u64::pow(10u64, dna_digits as u32);
                rand_source.next_u64_in_range(0u64, max_dna_value)
            }

            #[endpoint]
            fn create_random_zombie(&self, name: ManagedBuffer) {
                let caller = self.blockchain().get_caller();
                require!(
                    self.owned_zombies(&caller).is_empty(),
                    "You already own a zombie"
                );
                let rand_dna = self.generate_random_dna();
                self.create_zombie(caller, name, rand_dna);
            }

            #[event("newZombieEvent")]
            fn new_zombie_event(
                &self,
                #[indexed] zombie_id: usize,
                name: &ManagedBuffer,
                #[indexed] dna: u64,
            );
        }
      "storage.rs": |
        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        use crate::zombie::Zombie;

        #[multiversx_sc::module]
        pub trait Storage {
            #[storage_mapper("dnaDigits")]
            fn dna_digits(&self) -> SingleValueMapper<u8>;

            #[storage_mapper("zombieLastIndex")]
            fn zombie_last_index(&self) -> SingleValueMapper<usize>;

            #[view]
            #[storage_mapper("zombies")]
            fn zombies(&self, id: &usize) -> SingleValueMapper<Zombie<Self::Api>>;

            #[storage_mapper("zombieOwner")]
            fn zombie_owner(&self, id: &usize) -> SingleValueMapper<ManagedAddress>;

            #[storage_mapper("ownedZombies")]
            fn owned_zombies(&self, owner: &ManagedAddress) -> UnorderedSetMapper<usize>;
        }
      "lib.rs": |
        #![no_std]

        multiversx_sc::imports!();
        multiversx_sc::derive_imports!();

        mod storage;
        mod zombie;
        mod zombie_factory;
        mod zombie_feeding;

        #[multiversx_sc::contract]
        pub trait ZombiesContract:
            zombie_factory::ZombieFactory
            + zombie_feeding::ZombieFeeding
            + storage::Storage
        {
            #[init]
            fn init(&self) {
                self.dna_digits().set(16u8);
                self.zombie_last_index().set(1usize);
            }

            #[upgrade]
            fn upgrade(&self) {}
        }
    answer: |
        use multiversx_sc::derive_imports::*;
            
        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Kitty {
            pub genes: KittyGenes,
            pub birth_time: u64,   // timestamp
            pub cooldown_end: u64, // timestamp, used for pregnancy timer and siring cooldown
            pub matron_id: u32,
            pub sire_id: u32,
            pub siring_with_id: u32, // for pregnant cats, 0 otherwise
            pub nr_children: u16,    // cooldown period increases exponentially with every breeding/siring
            pub generation: u16,     // max(sire_gen, matron_gen) + 1. Generation also influences cooldown.
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct KittyGenes {
            pub fur_color: Color,
            pub eye_color: Color,
            pub meow_power: u8, // the higher the value, the louder the cat
        }

        #[type_abi]
        #[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
        pub struct Color {
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }
---

It's time to feed our zombies! And what do zombies like to eat most?

Well it just so happens that CryptoZombies love to eat...

**CryptoKitties!** ðŸ˜±ðŸ˜±ðŸ˜±

(Yes, I'm serious ðŸ˜† )

In order to do this we'll need to read the kittyDna from the CryptoKitties smart contract. We can do that because the CryptoKitties data is stored openly on the blockchain. Isn't the blockchain cool?!

Don't worry â€” our game isn't actually going to hurt anyone's CryptoKitty. We're only *reading* the CryptoKitties data, we're not able to actually delete it ðŸ˜‰

## Interacting with other contracts

For our contract to talk to another contract on the blockchain that we don't own, first we need to define a **_Proxy_**.

Let's look at a simple example. Say there was a contract on the blockchain that looked like this:

```rust
#[multiversx_sc::contract]
pub trait Adder {

    ...

    #[endpoint]
    fn add(&self, a: BigUint, b: BigUint) -> BigUint {
        a + b
    }
}
```

This would be a simple contract where you would sum up 2 numbers and return their sum.

Now let's say we had an external contract wants to use our `add` endpoint within the `Adder` contract.

First we'd have to generate a **_Proxy_** of the `Adder` contract. To do so, in the root of the `Adder` contract we create a new file called `sc-config.toml` containing the following:

```toml
[settings]

[[proxy]]
path = "src/adder_proxy.rs"

```
Next, inside a terminal from the root of the `Adder` contract we call `sc-meta all proxy`, generating the file we defined before. After that all we need to do is to bring this new generated file inside our contract's root.

>Note: you can actually generate a copy of the proxy file inside our contract by simply specifying it's relative path:

```toml
[settings]

[[proxy]]
path = "src/adder_proxy.rs"

[[proxy]]
path = "../../my-contract/src/adder_proxy.rs"
```

The proxy of a contract mainly contains the prototypes of the endpoints, allowing us to call them from inside another contract.

# Put it to the test

We've sketched some CryptoKitties source code for you showing how a `get_kitty` function would look like. From here we are interested of its return type which includes its "genes" (which is what our zombie game needs to form a new zombie!).

The MultiversX version of the `CryptoKitties` contract looks like this:

```rust
multiversx_sc::imports!();
multiversx_sc::derive_imports!();

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct Kitty {
    pub genes: KittyGenes,
    pub birth_time: u64,   // timestamp
    pub cooldown_end: u64, // timestamp, used for pregnancy timer and siring cooldown
    pub matron_id: u32,
    pub sire_id: u32,
    pub siring_with_id: u32, // for pregnant cats, 0 otherwise
    pub nr_children: u16,    // cooldown period increases exponentially with every breeding/siring
    pub generation: u16,     // max(sire_gen, matron_gen) + 1. Generation also influences cooldown.
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct KittyGenes {
    pub fur_color: Color,
    pub eye_color: Color,
    pub meow_power: u8, // the higher the value, the louder the cat
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

[multiversx_sc::contract]
pub trait KittyOwnership {

  ...

    #[view(getKittyById)]
    fn get_kitty_by_id_endpoint(&self, kitty_id: u32) -> Kitty {
        ...
    }
}
```

We generated the Crypto Kitties proxy for this lesson and can ve viewed in `kitty_ownership_proxy.rs`
Now that we know what the genes look like and what the `get_kitty_by_id_endpoint`, we can prepare ourselved to use the proxy, by makins sure our contract knows these elements.

1. Import the `Kitty`, `KittyGenes` and `Color` in `kitty_obj.rs`
