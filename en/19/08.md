---
title: Constructor in a constructor
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode: |
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory /*inherit functionality of VRFConsumerBaseV2*/ {

            //create all the new variables required by Chainlink VRF

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            //create constructor

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
    answer: >
       pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {

            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
---


You got it! The `VRFConsumerBaseV2` and `VRFCoordinatorV2Interface` contracts includes all the code we need to send a randomness request to a Chainlink oracle.

Now, as we said, to interact with a Chainlink node to request randomness, we need to know a few variables:

- The subscription ID that this contract belongs to. This is so the Subscription Manager knows which account to for payment of LINK for each request
- The VRF coordinator contract address. This is needed to verify that the number we get is actually random.
- The Chainlink node keyhash. This is used identify which Chainlink node we want to work with.
- The Chainlink node fee. This represents the fee (gas) the Chainlink will charge us, expressed in `LINK` tokens.
- The Callback Gas Limit. This determines the gas limit you want to specify for the callback transaction that writes the result on-chain.
- The number of requeset confirmations. This determines how many confirmations to wait before assuming the result is valid.
- The number of random numbers to receive back, because you can request multiple random numbers.



You can find some these variables in the <a href="https://docs.chain.link/docs/vrf-contracts/" target="_blank">Chainlink VRF Contract addresses documentation page</a>. Once again, the addresses will be different across networks, but for the scope of this lesson we will again be working with the Rinkeby network. For the ones that aren't found in the Chainlink docs, you need to decide and set them yourself.

As you look at them all, you might ask 'where do I get the subscription ID from'? The answer is, you need to go to the <a href="https://vrf.chain.link/" target="_blank">Chainlink Subscription Manager</a>, and <a href="https://docs.chain.link/docs/get-a-random-number/#create-and-fund-a-subscription">create a new subscription</a> that you can use. Once you've created one, you'll be given a subscription ID. This is the number you would put in your smart contract as the subscription ID. You don't need to do this step now for this example as we're just focusing on the smart contract code, but just be aware of it for when you try Chainlink VRF on a live public network.


Speaking of our smart contract, as said in the last lesson, we are going to inherit the functionality of this `VRFConsumerBaseV2`. But how do we implement a constructor of an inherited contract? And the answer is that we can have a constructor in a constructor.

Let's take a look at this sample code:

```javascript
import "./Y.sol";
contract X is Y {
    constructor() Y() public{
    }
}
```

To use a constructor of an inherited contract, we just put the constructor declaration as part of our contract's constructor.

We can do the same thing with the `VRFConsumerBaseV2` contract:

```javascript
constructor() VRFConsumerBaseV2(vrfCoordinator) {

}
```

## Putting it to the test

1. Have our `ZombieFactory` contract inherit from the `VRFConsumerBaseV2` contract. If you don't remember the syntax, here's an example:

  ```javascript
  // Create a contract named `parent`
  contract parent {

  }

  // Create a contract named `child` that inherits from `parent`
  contract child is parent {

  }
  ```

2. Add the following variables in the ZombieFactory contract. They will be required for the call to VRF
  - `COORDINATOR`, of type `VRFCoordinatorV2Interface`
  - `s_subscriptionId`, a `uint64`.
  - `vrfCoordinator`, an `address` hard-coded to the Rinkeby coordinator address of `0x6168499c0cFfCaCD319c818142124B7A15E857ab`
  - `keyHash`, a `bytes32` hard-coded to the 30 gwei Key Hash on Rinkeby `0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc`
  - `callbackGasLimit`, a `uint32` set to the value `100000`
 - `requestConfirmations`, a `uint16` set to the value `3`
 - `numWords`, a `uint32` set to the value `1`
 - `s_requestId`, a public `uint256`
 - `s_owner`, an `address`


3. Create a constructor for the `ZombieFactory` contract that takes a uint64 input parameter called '`subscriptionId`. The construction should call the constructor of the `VRFConsumerBaseV2` contract, passing with addresses of the VRF Coordinator from the Rinkeby network as an argument. Again, if you don't remember the syntax, check the example we provided above. Leave the body of the constructor blank for now.

 > Wondering where some of these values came from? We did all the legwork for you, and pulled them from the <a href="https://docs.chain.link/docs/vrf-contracts/#rinkeby" target="_blank">Chainlink VRF Contract Addresses</a> page of the Chainlink documentation.



