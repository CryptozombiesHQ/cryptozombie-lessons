---
title: Delete the old pseudo-random number generator
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode: |
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            uint256[] public s_randomWords;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
                s_owner = msg.sender;
                s_subscriptionId = subscriptionId;
            }

            function requestRandomWords() external onlyOwner {
                s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
                );
            }

            function fulfillRandomWords(uint256, uint256[] memory randomWords
                ) internal override {
                s_randomWords = randomWords;
            }

            modifier onlyOwner() {
                require(msg.sender == s_owner);
                _;
            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            // 1. Delete the function below
            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
    answer: >
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            uint256[] public s_randomWords;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
                s_owner = msg.sender;
                s_subscriptionId = subscriptionId;
            }

            function requestRandomWords() external onlyOwner {
                s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
                );
            }

            function fulfillRandomWords(uint256, uint256[] memory randomWords
                ) internal override {
                s_randomWords = randomWords;
            }

            modifier onlyOwner() {
                require(msg.sender == s_owner);
                _;
            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

        }
---


Boom! You've done it! Your contract now can get a verifiable random number!

Now let's delete the old pseudo-random number generator! We are using TRUE randomness now!


## Putting it to the test

1. Delete the old pseudo-random number generator.

> When you finish this lesson, you can learn more about Chainlink and random numbers by following the <a href="https://docs.chain.link/docs/intermediates-tutorial/" target="_blank">Random Numbers Tutorial</a>.
