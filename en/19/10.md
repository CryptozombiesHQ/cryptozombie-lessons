---
title: The requestRandomWords and fulfillRandomWords functions
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode: |
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            uint256[] public s_randomWords;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
                s_owner = msg.sender;
                s_subscriptionId = subscriptionId;
            }

            //1. Create requestRandomWords function

            //2. Create fulfillRandomWords function

            //3. Create onlyOwner modifier

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
    answer: >
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            uint256[] public s_randomWords;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
                s_owner = msg.sender;
                s_subscriptionId = subscriptionId;
            }

            function requestRandomWords() external onlyOwner {
                s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
                );
            }

            function fulfillRandomWords(uint256, uint256[] memory randomWords
                ) internal override {
                s_randomWords = randomWords;
            }

            modifier onlyOwner() {
                require(msg.sender == s_owner);
                _;
            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
---


Perfect! Now we can create our function that calls the Chainlink node.

Remember, Chainlink VRF follows the basic request model, so we need to define:

1. A function to request the random number

2. A function for the Chainlink node to return the random number to.

Remember, the Chainlink node is actually going to call the VRF Coordinator first to verify the number is random, then the VRF Coordinator will be the one to call our `ZombieFactory` contract.

Since we are importing the `VRFConsumerBaseV2` contract, we can use the two built in functions that do both of these!

A. `requestRandomWords`
   1. This function interacts with the VRFV2 coordinator contract, and tells it that it wants to make a request for randomness, passing in all the relevant details such as the keyhash, subscription ID, number of confirmations, callback gas limit, and how many random numbers to return.
   2. The result of this request is a request ID which is stored in the `s_requestId` variable.

B. `fulfillRandomWords`
   1. The Chainlink node first calls a function on the VRF Coordinator and includes the random numbers.
   2. The VRF Coordinator verifies that the random number(s) are truly random.
   3. Then, it returns the random number(s) the Chainlink node created, along with the original requestID from our request to the smart contract that requested the randomness.

C. We want to ensure only the contract owner can do a request for randomness, so we'll create a modifier `onlyOwner` to enforce this.

So, let's create these functions in our contract.

## Putting it to the test

1. Create a function named `requestRandomWords`. It is an `external` function with no return value. The function definition should also specify the `onlyOwner` modifier after the `external` keyword. The body of the function should set the value of `s_request_id` to the result of calling the `COORDINATOR.requestRandomWords()` function, passing in the following input paramters:
  - keyHash,
  - s_subscriptionId,
  - requestConfirmations,
  - callbackGasLimit,
  - numWords

For more details, see the see the <a href="https://docs.chain.link/docs/get-a-random-number/" target="_blank">Get a Random Number</a> page of the Chainlink documentation.


2. Create an `internal override` function named `fulfillRandomWords` that takes two arguments: the first should be of type `uint256` and not have a name specified (as we don't have any logic that uses it in the function body), and an array of uint256 called `randomWords`. The second parameter should be specifically stored in memory by specifying the `memory` keyword before the variable name. Finally, the function body should assign the response of the VRF request (the `randomWords` argument) to the `s_randomWords` variable.

> Note: Why did we make this function `internal override`? That's because only the VRF Coordinator contract calls this function.

3. Create a new modifier called `onlyOwner()`, that should run an assertion check to require that `(msg.sender == s_owner);`, then if the result is true, continue with function execution `_;`. This is the same as the modifier we created earlier in Chapter 3:

    ```
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    ```