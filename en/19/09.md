---
title: Define our Chainlink VRF variables
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode: |
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            //1. create new variable to store random numbers

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                //2. complete the constructor body
            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
    answer: >
        pragma solidity ^0.8.7;

        import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
        import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

        contract ZombieFactory is VRFConsumerBaseV2 {

            VRFCoordinatorV2Interface COORDINATOR;
            uint64 s_subscriptionId;
            address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
            bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
            uint32 callbackGasLimit = 100000;
            uint16 requestConfirmations = 3;
            uint32 numWords =  1;
            uint256 public s_requestId;
            address s_owner;
            uint256[] public s_randomWords;

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;

            struct Zombie {
                string name;
                uint dna;
            }

            Zombie[] public zombies;

            constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
                COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
                s_owner = msg.sender;
                s_subscriptionId = subscriptionId;
            }

            function _createZombie(string memory _name, uint _dna) private {
                zombies.push(Zombie(_name, _dna));
            }

            function _generatePseudoRandomDna(string memory _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

        }
---

Now this next part is pretty easy, we just need to set our `coordinator`, `owner` and `subscription ID` in our constructor. We also should also create an array of integers called `s_randomWords` that will store the returned random numbers.

## Putting it to the test


1. Define a new `public` variable `s_randomWords`, an array of `uint256`


2. Fill in the body of the newly created constructor, by seting the COORDINATOR variable to the result of calling `VRFCoordinatorV2Interface(vrfCoordinator)`. Then set the values of s_owner to `msg.sender`, and s_subscriptionId to the `subscriptionId` input parameter.


