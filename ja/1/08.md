---
title: The getLatestEthPrice Function
actions:
  - 'checkAnswer'
  - 'hints'
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "oracle/EthPriceOracle.sol": |
        pragma solidity 0.5.0;
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        import "./CallerContractInterface.sol";
        contract EthPriceOracle is Ownable {
        uint private randNonce = 0;
        uint private modulus = 1000;
        mapping(uint256=>bool) pendingRequests;
        event GetLatestEthPriceEvent(address callerAddress, uint id);
        event SetLatestEthPriceEvent(uint256 ethPrice, address callerAddress);
        // Start here
        }
      "caller/CallerContract.sol": |
        pragma solidity 0.5.0;
        import "./EthPriceOracleInterface.sol";
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        contract CallerContract is Ownable {
        uint256 private ethPrice;
        EthPriceOracleInterface private oracleInstance;
        address private oracleAddress;
        mapping(uint256=>bool) myRequests;
        event newOracleAddressEvent(address oracleAddress);
        event ReceivedNewRequestIdEvent(uint256 id);
        event PriceUpdatedEvent(uint256 ethPrice, uint256 id);
        function setOracleInstanceAddress (address _oracleInstanceAddress) public onlyOwner {
        oracleAddress = _oracleInstanceAddress;
        oracleInstance = EthPriceOracleInterface(oracleAddress);
        emit newOracleAddressEvent(oracleAddress);
        }
        function updateEthPrice() public {
        uint256 id = oracleInstance.getLatestEthPrice();
        myRequests[id] = true;
        emit ReceivedNewRequestIdEvent(id);
        }
        function callback(uint256 _ethPrice, uint256 _id) public onlyOracle {
        require(myRequests[_id], "This request is not in my pending list.");
        ethPrice = _ethPrice;
        delete myRequests[_id];
        emit PriceUpdatedEvent(_ethPrice, _id);
        }
        modifier onlyOracle() {
        require(msg.sender == oracleAddress, "You are not authorized to call this function.");
        _;
        }
        }
      "calller/EthPriceOracleInterface.sol": |
        pragma solidity 0.5.0;
        contract EthPriceOracleInterface {
        function getLatestEthPrice() public returns (uint256);
        }
      "oracle/CallerContractInterface.sol": |
        pragma solidity 0.5.0;
        contract CallerContractInterface {
        function callback(uint256 _ethPrice, uint256 id) public;
        }
    answer: |
      pragma solidity 0.5.0;
      import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
      import "./CallerContractInterface.sol";
      contract EthPriceOracle is Ownable {
      uint private randNonce = 0;
      uint private modulus = 1000;
      mapping(uint256=>bool) pendingRequests;
      event GetLatestEthPriceEvent(address callerAddress, uint id);
      event SetLatestEthPriceEvent(uint256 ethPrice, address callerAddress);
      function getLatestEthPrice() public returns (uint256) {
      randNonce++;
      uint id = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % modulus;
      }
      }
---

Great job! You've just finished implementing the caller smart contractðŸ’ªðŸ»ðŸ’ªðŸ»ðŸ’ªðŸ».

Now it's time to move forward to the oracle contract. Let's start by taking a look into what this contract should do.

The gist of it is that the oracle contract acts as a bridge, enabling the caller contracts to access the ETH price feed. To achieve this, it just implements two functions: `getLatestEthPrice` and `setLatestEthPrice`.

## The getLatestEthPrice Function

To allow the callers to track their requests, the `getLatestEthPrice` function should first compute the request `id` and, for security reasons, this number should be hard to guess.

What security reasons, you ask?

In the third lesson, you're going to make the oracle more decentralized. Generating a unique id makes it harder for oracles to collude and manipulate the price for a particular request.

In other words, you would want to generate a **random number**.

But how can you generate a random number in Solidity?

One solution would be to let loose a zombie on a keyboard. But the poor zombie will also type spaces and letters so your "random number" will end up looking like this: `erkljf3r4398r4390r830`.

So, even if no zombies were hurt in the making of this lesson, that solution for generating a random number is simply not good enoughðŸ˜Ž.

However, in Solidity, you can compute a "good-enough" random number using the `keccak256` function like this:

```solidity
uint randNonce = 0;
uint modulus = 1000;
uint randomNumber = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % modulus;

```

The above takes the timestamp of `now`, the `msg.sender`, and an incrementing `nonce` (a number that is only ever used once, so we don't run the same hash function with the same input parameters twice). Then it packs the inputs and uses `keccak256` to convert them to a random hash. Next, it converts the hash to a `uint`. Finally, it uses `% modulus` to take only the last 3 digits. This gives you a "good-enough" random number between 0 and `modulus`.

> Lesson 4 explains why this approach is not 100% secure and provides a few alternatives for generating truly secure random numbers. Give it a read once you've finished this lesson.

## Put It to the Test

We've created a shell for the `EthPriceOracle` contract. Take a quick browse through the code before continuing. Note that your contract is `Ownable` and we've also included the content of the `CallerContractInterface.sol` file.

1. At the bottom of your contract, define a function named `getLatestEthPrice` that returns a `uint256`. It should be a `public` function.
2. On the first line, use `randNonce++` to increment `randNonce`.
3. Compute a random number between 0 and `modulus`, and store the result in a `uint` called `id`. If you get stuck, feel free to take a look at the example above where we generated a random numberðŸ˜‰. Your solution should be similar.

You'll continue fleshing out the `getLatestEthPrice` function in the next chapter.
