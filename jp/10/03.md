---
title: ソースコードをコンパイルする
actions: ['答え合わせ', 'ヒント']
requireLogin: true
material:
  terminal:
    help:
      You should probably run `truffle compile`.
    commands:
        "truffle compile":
            hint: truffle compile
            output: |
                Compiling ./contracts/Migrations.sol...
                Compiling ./contracts/CryptoZombies.sol...
                Compiling ./contracts/erc721.sol...
                Compiling ./contracts/ownable.sol...
                Compiling ./contracts/safemath.sol...
                Compiling ./contracts/zombieattack.sol...
                Compiling ./contracts/zombiefactory.sol...
                Compiling ./contracts/zombiefeeding.sol...
                Compiling ./contracts/zombiehelper.sol...
                Compiling ./contracts/zombieownership.sol...
                Writing artifacts to ./build/contracts
---

おめでとう！プロジェクト構成を整え、`truffle-hdwallet-provider`をセットアップできた。さあ、我々のコントラクトをコンパイルするぞ。

なぜコンパイルが必要か、聞きたいか？

_Ethereumの仮想マシン_ はSolidityで書かれたソースコードを直接理解することはできない。従って、コンパイラーを動かし、機械が読める **_bytecode_** に翻訳する必要があるのだ。次に、仮想マシンがバイトコードを実行し、我々のスマートコントラクトが要求するアクションの数々を実行する。

バイトコードがどんな感じか興味があるか？少し見てみるか:

```
"0x60806040526010600155600154600a0a6002556201518060035566038d7ea4c6800060085560006009556046600a55336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1..."
```

この通り、人間どもにとってバイトコードは現実のゾンビと同じくらい理解しがたいものだろう！

## Solidityのコンパイラーを使用する

Solidityのコンパイラーの話をするなら、開発者達が用意してくれた気の利いた機能について言及せねばなるまい。

`SafeMath`に含まれる`add`関数の定義を次のように修正する:

```
function add(uint16 a, uint16 b) internal returns (uint16) {
    uint16 c = a + b;
    assert(c >= a);
    return c;
}
```

この関数をコンパイルすると、Solidityのコンパイラーは次のような **_警告_** を発するであろう:

```
safemath.sol:110:11: Warning: Function state mutability can be restricted to pure
          function add(uint16 a, uint16 b) internal returns (uint16) {
          ^ (Relevant source part starts here and spans across multiple lines).
```

コンパイラーが言わんとしていることは、この関数はブロックチェーンに読み書きしないから`pure`修飾子を使用せよということだ。

なぜ重要かって？

そう、`pure` や `view`関数はガスを節約できるのであった。関数がブロックチェーンの状態を変更しないのであれば、マイニングする必要がないのだ。言ってしまえば、`pure` や `view`関数は無料で`呼べる`。


## CryptoZombies- The Game

覚えているか？我々はロジックを`ZombieOwnership.sol`という名のスマートコントラクトに書いたであろう。

うーむ…ゲームにとってイケてる名前とは言い難い。

幸運にも、名前は問題にならない。継承すれば、同じアクションと機能を持つスマートコントラクトを、任意の名前で作れるからな。

さあ、`CryptoZombies`という名前の新たなコントラクトを、`ZombieOwnership.sol`を継承して作成するぞ:

```solidity
pragma solidity ^0.4.24;

import "./zombieownership.sol";

contract CryptoZombies is ZombieOwnership
    {

    }
```

次に、スマートコントラクトを全て`./contracts`フォルダーにコピーするぞ。すると、プロジェクトの構成は次のようになるはずだ:

```
.
├── contracts
    ├── Migrations.sol
    ├── CryptoZombies.sol
    ├── erc721.sol
    ├── ownable.sol
    ├── safemath.sol
    ├── zombieattack.sol
    ├── zombiefactory.sol
    ├── zombiefeeding.sol
    ├── zombiehelper.sol
    ├── zombieownership.sol
├── migrations
└── test
```

これで準備は整った。さあ、我々のプロジェクトをコンパイルしようではないか。

# さあテストだ

1. `truffle compile`コマンドを叩け。このコマンドはビルドされた中間生成物を、`./build/contracts`に置いてくれる。

 > 注: この中間生成物は、スマートコントラクトのバージョン、ABIおよび **Truffle** が使用する内部データで構成された「バイトコード」だ。編集するんじゃないぞ。さもないと **Truffle** が正常に動かなくなるぞ。
