---
title: èƒŒæ™¯çŸ¥è¯†åŠå¦‚ä½•å¼€å§‹
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
        "ZombieToken.sol": |
          //start here

        "ERC721XToken.sol": |

          // Full implementation with all included files at https://github.com/loomnetwork/erc721x

          pragma solidity ^0.4.25;

          import "./../../Interfaces/ERC721X.sol";

          import "./../../Interfaces/ERC721XReceiver.sol";
          import "./ERC721XTokenNFT.sol";

          import "openzeppelin-solidity/contracts/AddressUtils.sol";
          import "./../../Libraries/ObjectsLib.sol";


          // Additional features over NFT token that is compatible with batch transfers
          contract ERC721XToken is ERC721X, ERC721XTokenNFT {

              using ObjectLib for ObjectLib.Operations;
              using AddressUtils for address;

              bytes4 internal constant ERC721X_RECEIVED = 0x660b3370;
              bytes4 internal constant ERC721X_BATCH_RECEIVE_SIG = 0xe9e5be6a;

              event BatchTransfer(address from, address to, uint256[] tokenTypes, uint256[] amounts);


              modifier isOperatorOrOwner(address _from) {
                  require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");
                  _;
              }

              function implementsERC721X() public pure returns (bool) {
                  return true;
              }

              /**
               * @dev transfer objects from different tokenIds to specified address
               * @param _from The address to BatchTransfer objects from.
               * @param _to The address to batchTransfer objects to.
               * @param _tokenIds Array of tokenIds to update balance of
               * @param _amounts Array of amount of object per type to be transferred.
               * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
               */
              function _batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts)
                  internal
                  isOperatorOrOwner(_from)
              {

                  // Requirements
                  require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");
                  require(_to != address(0), "Invalid recipient");

                  if (tokenType[_tokenIds[0]] == NFT) {
                      tokenOwner[_tokenIds[0]] = _to;
                      emit Transfer(_from, _to, _tokenIds[0]);
                  }

                  // Load first bin and index where the object balance exists
                  (uint256 bin, uint256 index) = ObjectLib.getTokenBinIndex(_tokenIds[0]);

                  // Balance for current bin in memory (initialized with first transfer)
                  // Written with bad library syntax instead of as below to bypass stack limit error
                  uint256 balFrom = ObjectLib.updateTokenBalance(
                      packedTokenBalance[_from][bin], index, _amounts[0], ObjectLib.Operations.SUB
                  );
                  uint256 balTo = ObjectLib.updateTokenBalance(
                      packedTokenBalance[_to][bin], index, _amounts[0], ObjectLib.Operations.ADD
                  );

                  // Number of transfers to execute
                  uint256 nTransfer = _tokenIds.length;

                  // Last bin updated
                  uint256 lastBin = bin;

                  for (uint256 i = 1; i < nTransfer; i++) {
                      // If we're transferring an NFT we additionally should update the tokenOwner and emit the corresponding event
                      if (tokenType[_tokenIds[i]] == NFT) {
                          tokenOwner[_tokenIds[i]] = _to;
                          emit Transfer(_from, _to, _tokenIds[i]);
                      }
                      (bin, index) = _tokenIds[i].getTokenBinIndex();

                      // If new bin
                      if (bin != lastBin) {
                          // Update storage balance of previous bin
                          packedTokenBalance[_from][lastBin] = balFrom;
                          packedTokenBalance[_to][lastBin] = balTo;

                          // Load current bin balance in memory
                          balFrom = packedTokenBalance[_from][bin];
                          balTo = packedTokenBalance[_to][bin];

                          // Bin will be the most recent bin
                          lastBin = bin;
                      }

                      // Update memory balance
                      balFrom = balFrom.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.SUB);
                      balTo = balTo.updateTokenBalance(index, _amounts[i], ObjectLib.Operations.ADD);
                  }

                  // Update storage of the last bin visited
                  packedTokenBalance[_from][bin] = balFrom;
                  packedTokenBalance[_to][bin] = balTo;

                  // Emit batchTransfer event
                  emit BatchTransfer(_from, _to, _tokenIds, _amounts);
              }

              function batchTransferFrom(address _from, address _to, uint256[] _tokenIds, uint256[] _amounts) public {
                  // Batch Transfering
                  _batchTransferFrom(_from, _to, _tokenIds, _amounts);
              }

              /**
               * @dev transfer objects from different tokenIds to specified address
               * @param _from The address to BatchTransfer objects from.
               * @param _to The address to batchTransfer objects to.
               * @param _tokenIds Array of tokenIds to update balance of
               * @param _amounts Array of amount of object per type to be transferred.
               * @param _data Data to pass to onERC721XReceived() function if recipient is contract
               * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).
               */
              function safeBatchTransferFrom(
                  address _from,
                  address _to,
                  uint256[] _tokenIds,
                  uint256[] _amounts,
                  bytes _data
              )
                  public
              {

                  // Batch Transfering
                  _batchTransferFrom(_from, _to, _tokenIds, _amounts);

                  // Pass data if recipient is contract
                  if (_to.isContract()) {
                      bytes4 retval = ERC721XReceiver(_to).onERC721XBatchReceived(
                          msg.sender, _from, _tokenIds, _amounts, _data
                      );
                      require(retval == ERC721X_BATCH_RECEIVE_SIG);
                  }
              }

              function transfer(address _to, uint256 _tokenId, uint256 _amount) public {
                  _transferFrom(msg.sender, _to, _tokenId, _amount);
              }

              function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                  _transferFrom(_from, _to, _tokenId, _amount);
              }

              function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount)
                  internal
                  isOperatorOrOwner(_from)
              {
                  require(tokenType[_tokenId] == FT);
                  require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");
                  require(_to != address(0), "Invalid to address");

                  _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);
                  _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);
                  emit TransferWithQuantity(_from, _to, _tokenId, _amount);
              }

              function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {
                  safeTransferFrom(_from, _to, _tokenId, _amount, "");
              }

              function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes _data) public {
                  _transferFrom(_from, _to, _tokenId, _amount);
                  require(
                      checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),
                      "Sent to a contract which is not an ERC721X receiver"
                  );
              }

              function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {
                  // If the token doesn't exist, add it to the tokens array
                  if (!exists(_tokenId)) {
                      tokenType[_tokenId] = FT;
                      allTokens.push(_tokenId);
                  } else {
                      // if the token exists, it must be a FT
                      require(tokenType[_tokenId] == FT, "Not a FT");
                  }

                  _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);
                  emit TransferWithQuantity(address(this), _to, _tokenId, _supply);
              }


              function checkAndCallSafeTransfer(
                  address _from,
                  address _to,
                  uint256 _tokenId,
                  uint256 _amount,
                  bytes _data
              )
                  internal
                  returns (bool)
              {
                  if (!_to.isContract()) {
                      return true;
                  }

                  bytes4 retval = ERC721XReceiver(_to).onERC721XReceived(
                      msg.sender, _from, _tokenId, _amount, _data);
                  return(retval == ERC721X_RECEIVED);
              }

          }
    answer: >
      pragma solidity ^0.4.25;

      import "./ERC721XToken.sol";

      contract ZombieCard is ERC721XToken {

      }
---

åœ¨æœ¬è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªç¤ºä¾‹åŒºå—é“¾æ¸¸æˆçš„ä»£å¸åˆçº¦ã€‚

å®ƒå¤§è‡´åŸºäºLoom Networkæˆ‘ä»¬è‡ªå·±çš„æ¸¸æˆâ€œåƒµå°¸æˆ˜åœºâ€ä¸­å®ç°ERC721xçš„æ–¹å¼ â€”â€” â€œåƒµå°¸æˆ˜åœºâ€ä¸€æ¬¾ç±»ä¼¼"ä¸‡æ™ºç‰Œ"æˆ–â€œç‚‰çŸ³â€çš„åŸºäºåŒºå—é“¾çš„é›†æ¢å¼å¡ç‰Œæ¸¸æˆã€‚

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œä½ å¯ä»¥äº†è§£çœŸå®ä¸–ç•Œçš„ç”¨ä¾‹ï¼Œå¹¶ä¸”åœ¨å®Œæˆæœ¬è¯¾ç¨‹åï¼Œå°†èƒ½æ›´å¥½åœ°å°†è¯¥å®ç°åº”ç”¨åˆ°ä½ è‡ªå·±çš„æ¸¸æˆä¸­ã€‚

åœ¨ç¬¬ä¸€ç« ï¼Œæˆ‘ä»¬å…ˆä»ä¸€äº›èƒŒæ™¯çŸ¥è¯†å¼€å§‹ï¼Œç¡®ä¿æˆ‘ä»¬è·å¾—ä¸€è‡´çš„ä¿¡æ¯......

## èƒŒæ™¯çŸ¥è¯†ï¼šä»£å¸åˆ°åº•æ˜¯ä»€ä¹ˆ?

å°†æ¸¸æˆä¸­çš„ç‰©å“ç§°ä¸ºâ€œä»£å¸â€å¯èƒ½ä¼šè®©äººäº§ç”Ÿè¯¯è§£ï¼Œå› ä¸ºâ€œä»£å¸â€ä¸€è¯æš—æŒ‡åƒè´§å¸ä¸€æ ·èŠ±è´¹çš„ä¸œè¥¿ã€‚

ä½†æ˜¯ï¼Œä»¥å¤ªåŠä¸Šçš„**_token_**ä¸€è¯åªæ˜¯æŒ‡æ™ºèƒ½åˆçº¦çš„æ ‡å‡†ï¼Œå®ƒä»¬éƒ½å®ç°ç›¸åŒçš„é€šç”¨å‡½æ•°ï¼Œä¾‹å¦‚`transfer(address _to, uint256 _value)` å’Œ`balanceOf(address _owner)`ã€‚

æ˜¯çš„ï¼Œä½ å¯ä»¥è½¬ç§»å¹¶æ‹¥æœ‰è´§å¸ä½™é¢ â€”â€” ä½†ä¹Ÿå¯ä»¥è½¬ç§»å¹¶æ‹¥æœ‰ä¸€äº›æ¸¸æˆä¸­çš„ç‰©å“ï¼Œå¦‚å‰‘æˆ–æ‰‘å…‹ç‰Œã€‚

å°½ç®¡æ¸¸æˆä¸­çš„å‰‘ä¸åƒè´§å¸ä¸€æ ·å¯èŠ±è´¹ â€”â€” ä½†æˆ‘ä»¬*çš„ç¡®*å¸Œæœ›ç©å®¶æ‹¥æœ‰çš„ä»»ä½•ä¸œè¥¿éƒ½å…·æœ‰ç›¸åŒçš„åŸºæœ¬åŠŸèƒ½ã€‚

å› æ­¤ï¼Œâ€œä»£å¸â€çš„æ¦‚å¿µå¯¹äºæŠ½è±¡å‡ºè¿™äº›å¸¸ç”¨æ–¹æ³•éå¸¸æœ‰ç”¨ï¼Œå®ƒä»¬å¯ä»¥åº”ç”¨åˆ°æˆ‘ä»¬æ¸¸æˆçš„æ‰€æœ‰ç‰©å“ä¸­ â€”â€” è¿™æ ·ï¼Œä»¥å¤ªåŠä¸Šçš„æ‰€æœ‰æ¸¸æˆç‰©å“éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç•Œé¢ï¼Œå¹¶ä¸”å¯ä»¥å—ä»»ä½•éµå®ˆåŒä¸€ä»£å¸æ ‡å‡†çš„é’±åŒ…å’Œäº¤æ˜“å¸‚åœºæ‰€æ”¯æŒã€‚

## ä¸åŒçš„ä»£å¸æ ‡å‡†: ERC20 å’Œ ERC721

æœ€å¸¸è§çš„ä»£å¸æ ‡å‡†æ˜¯**_ERC20ä»£å¸_**ã€‚ è¿™äº›ä»£å¸çš„ä½œç”¨ç±»ä¼¼äºè´§å¸ã€‚ä½†å®ƒä»¬åœ¨è¡¨ç¤ºæ•°å­—ç‰©å“(å¦‚é›†æ¢å¼å¡ç‰Œæ¸¸æˆä¸­çš„å¡ç‰Œ)æ–¹é¢å¹¶ä¸æ˜¯ç‰¹åˆ«æœ‰ç”¨ã€‚

é¦–å…ˆï¼Œå¡ç‰Œä¸åƒè´§å¸ä¸€æ ·æ˜¯å¯åˆ†å‰²çš„ â€”â€” ä½ ä¸å¯èƒ½æ‹¥æœ‰ä¸€å¼ å¡ç‰Œçš„äº”åˆ†ä¹‹äºŒã€‚

å…¶æ¬¡ï¼Œå¹¶éæ‰€æœ‰å¡ç‰Œéƒ½æ˜¯å¹³ç­‰çš„ï¼Œæ‰€ä»¥å®ƒä»¬ä¸å¯äº’æ¢ã€‚ ä½ ä¸ä¼šæƒ³å°†ä½ çš„Z-Viruså¡æ¢æˆæˆ‘çš„Ozmozizã€‚

æœ‰å¦ä¸€ç§ä»£å¸æ ‡å‡†æ›´é€‚åˆåŠ å¯†æ”¶è—å“ â€”â€” å®ƒä»¬è¢«ç§°ä¸º**_ERC721ä»£å¸_**ã€‚

**_ERC721ä»£å¸_**æ˜¯**ä¸å¯**äº’æ¢çš„ã€‚æ¯ä¸ªç‰©å“éƒ½æ˜¯å”¯ä¸€çš„ï¼Œå¹¶ä¸”æœ‰å”¯ä¸€çš„IDã€‚å®ƒä»¬ä¹Ÿä¸èƒ½è¢«åˆ†å‰² â€”â€” ä½ åªèƒ½å°†å®ƒä»¬ä½œä¸ºæ•´ä½“æ¥äº¤æ˜“ã€‚

æ‰€ä»¥ï¼Œè¿™äº›ä»£å¸æ›´é€‚åˆåˆ¶ä½œæˆ‘ä»¬çš„é›†æ¢å¼å¡ç‰Œæ¸¸æˆã€‚

ä½ æœ‰æ³¨æ„åˆ°æˆ‘è¯´çš„æ˜¯å®ƒä»¬**æ›´åˆé€‚** â€”â€” è€Œä¸æ˜¯å®Œç¾ï¼Œå¯¹å§?ğŸ˜‰

## ERC721x â€”â€” ä¸¤å…¨å…¶ç¾çš„é€‰æ‹©

ERC721å¯¹äºæˆå†…ç‰©å“çš„é—®é¢˜åœ¨äºï¼Œå¤§å¤šæ•°æ¸¸æˆ**éƒ½æœ‰**ä¸€äº›ç›¸åŒçš„ç‰©å“ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬çš„å¡ç‰Œæ¸¸æˆæœ‰300å¼ ä¸åŒçš„å¡ç‰Œã€‚ ä½†æ˜¯æ¯ä¸€å¼ å¡ç‰Œéƒ½éœ€è¦ä¸æ­¢ä¸€ä¸ªå‰¯æœ¬ â€”â€” å¦åˆ™æ²¡æœ‰å¤šå°‘äººå¯ä»¥ç©æˆ‘ä»¬çš„æ¸¸æˆï¼

åŒä¸€å¼ å¡ç‰Œçš„å¤šä¸ªå‰¯æœ¬ï¼ˆå¤§éƒ¨åˆ†ï¼‰å¯äº’æ¢ã€‚ å› æ­¤ï¼Œæœ‰ä¸€ä¸ªè€ƒè™‘åˆ°è¿™ä¸€ç‚¹çš„ä»£å¸æ ‡å‡†å¾ˆé‡è¦ã€‚

ERC721xå…è®¸ä½ å®šä¹‰å¤šä¸ªä»£å¸ï¼ˆå°†å®ƒä»¬è§†ä¸ºå¡ç‰Œæ¨¡æ¿ï¼‰æ¥å¤„ç†æ­¤ç”¨ä¾‹ï¼Œå¹¶ä¸”å¯¹äºæ¯å¼ å¡ç‰Œï¼Œä½ å¯ä»¥å®šä¹‰è¯¸å¦‚å°†æ€»å…±å­˜åœ¨å¤šå°‘å¼ ä¹‹ç±»çš„å†…å®¹ã€‚

ä½ ä¼šçœ‹åˆ°å¦‚ä½•æ“ä½œï¼Œå› ä¸ºåœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­æˆ‘ä»¬å°†é€æ­¥å¼•å¯¼ä½ ã€‚ğŸ‘¨â€ğŸ«

## å¼€å§‹å§: åœ¨ä½ çš„é¡¹ç›®ä¸­ä½¿ç”¨ERC721x

å®ç°æ–°çš„ERC721xä»£å¸æ—¶ï¼Œæ²¡å¿…è¦ä»å¤´å¼€å§‹ã€‚ å°±åƒä½ é€šè¿‡ä»<a href="https://github.com/OpenZeppelin/openzeppelin-solidity" target=_blank>Open Zeppelin</a>ç­‰åœ°æ–¹å¤åˆ¶æ¨¡æ¿å¹¶è¿›è¡Œç›¸å…³æ›´æ”¹æ¥å¼€å§‹ERC20ä»£å¸ä¸€æ ·ï¼Œå¯¹äºERC721xï¼Œä½ å¯ä»¥å…ˆå°†æˆ‘ä»¬çš„å®ç°åŒ…å«åœ¨ä½ çš„é¡¹ç›®ä¸­ã€‚

è¦å°†å…¶åŒ…å«åœ¨ä½ æœªæ¥çš„é¡¹ç›®ä¸­ï¼Œå¯ä»¥æŒ‰ç…§æˆ‘ä»¬<a href="https://github.com/loomnetwork/erc721x" target=_blank>GitHubä¸­çš„è¯´æ˜</a>è¿›è¡Œæ“ä½œã€‚ ä½†æ˜¯å¯¹äºæœ¬è¯¾ï¼Œæˆ‘ä»¬å·²ç»å°†`ERC721XToken.sol`åŒ…å«åœ¨ä½ çš„é¡¹ç›®ä¸­äº†ã€‚

ä¸è¦æ‹…å¿ƒç†è§£ä¸äº†æ‰€æœ‰ä»£ç  â€”â€” æˆ‘ä»¬å°†é€æ­¥å¼•å¯¼ä½ å®Œæˆä½ éœ€è¦äº†è§£çš„éƒ¨åˆ†ã€‚

# å®æˆ˜æ¼”ä¹ 

è®©æˆ‘ä»¬ä»åŸºç¡€å¼€å§‹ï¼šæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªåä¸ºâ€œZombieCardâ€çš„æ–°åˆçº¦ï¼Œå®ƒç»§æ‰¿äº† `ERC721XToken`çš„é€»è¾‘ã€‚

1. é¦–å…ˆï¼Œåœ¨é¡¶éƒ¨å£°æ˜æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨`pragma solidity ^0.4.25`ã€‚

2. å£°æ˜pragmaä¹‹åï¼Œ`å¯¼å…¥` æ–‡ä»¶`./ERC721XToken.sol`ã€‚

3. æ¥ä¸‹æ¥ï¼Œå£°æ˜ä¸€ä¸ªåä¸ºâ€œZombieCardâ€çš„æ–°`åˆçº¦`ã€‚ å®ƒåº”è¯¥æ˜¯ä½¿ç”¨å…³é”®å­—`is`ç»§æ‰¿è‡ª`ERC721XToken`ã€‚ æš‚æ—¶å°†åˆçº¦æ­£æ–‡ç•™ç©ºã€‚

> æ³¨æ„ï¼šå¦‚æœä½ ä¸è®°å¾—åŸºç¡€çŸ¥è¯†ã€æ„Ÿåˆ°å›°æƒ‘äº†ï¼Œå¯ä»¥å¤ä¹ ä¸‹<a href="https://cryptozombies.io/en/lesson/1/chapter/2">ç¬¬1è¯¾ç¬¬2ç« </a>å’Œ<a href="https://cryptozombies.io/en/lesson/2/chapter/5">ç¬¬2è¯¾ç¬¬5ç« </a>ã€‚