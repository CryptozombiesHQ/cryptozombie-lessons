---
title: ERC721 ä»£å¸è½¬ç§» â€”â€” å•æ­¥åœºæ™¯
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
        "test/CryptoZombies.js": |
            const CryptoZombies = artifacts.require("CryptoZombies");
            const utils = require("./helpers/utils");
            const zombieNames = ["Zombie 1", "Zombie 2"];
            contract("CryptoZombies", (accounts) => {
                let [alice, bob] = accounts;
                let contractInstance;
                beforeEach(async () => {
                    contractInstance = await CryptoZombies.new();
                });
                it("should be able to create a new zombie", async () => {
                    const result = await contractInstance.createPseudoRandomZombie(zombieNames[0], {from: alice});
                    assert.equal(result.receipt.status, true);
                    assert.equal(result.logs[0].args.name,zombieNames[0]);
                })
                it("should not allow two zombies", async () => {
                    await contractInstance.createPseudoRandomZombie(zombieNames[0], {from: alice});
                    await utils.shouldThrow(contractInstance.createPseudoRandomZombie(zombieNames[1], {from: alice}));
                })
                xcontext("with the single-step transfer scenario", async () => {
                    it("should transfer a zombie", async () => {
                      // start here.
                    })
                })
                xcontext("with the two-step transfer scenario", async () => {
                    it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                      // TODO: Test the two-step scenario.  The approved address calls transferFrom
                    })
                    it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                        // TODO: Test the two-step scenario.  The owner calls transferFrom
                     })
                })
            })
        "test/helpers/utils.js": |
            async function shouldThrow(promise) {
            try {
                await promise;
                assert(true);
            }
            catch (err) {
                return;
            }
            assert(false, "The contract did not throw.");

            }

            module.exports = {
                shouldThrow,
            };
    answer: >
        const CryptoZombies = artifacts.require("CryptoZombies");

        const utils = require("./helpers/utils");

        const zombieNames = ["Zombie 1", "Zombie 2"];

        contract("CryptoZombies", (accounts) => {
            let [alice, bob] = accounts;
            let contractInstance;
            beforeEach(async () => {
                contractInstance = await CryptoZombies.new();
            });
            it("should be able to create a new zombie", async () => {
                const result = await contractInstance.createPseudoRandomZombie(zombieNames[0], {from: alice});
                assert.equal(result.receipt.status, true);
                assert.equal(result.logs[0].args.name,zombieNames[0]);
            })
            it("should not allow two zombies", async () => {
                await contractInstance.createPseudoRandomZombie(zombieNames[0], {from: alice});
                await utils.shouldThrow(contractInstance.createPseudoRandomZombie(zombieNames[1], {from: alice}));
            })
            context("with the single-step transfer scenario", async () => {
                it("should transfer a zombie", async () => {
                    const result = await contractInstance.createPseudoRandomZombie(zombieNames[0], {from: alice});
                    const zombieId = result.logs[0].args.zombieId.toNumber();
                    await contractInstance.transferFrom(alice, bob, zombieId, {from: alice});
                    const newOwner = await contractInstance.ownerOf(zombieId);
                    assert.equal(newOwner, bob);
                })
            })
            xcontext("with the two-step transfer scenario", async () => {
                it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
                  // TODO: Test the two-step scenario.  The approved address calls transferFrom
                })
                it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
                    // TODO: Test the two-step scenario.  The owner calls transferFrom
                 })
            })
        })
---

æˆªè‡³ç›®å‰ï¼Œæˆ‘ä»¬éƒ½åªæ˜¯åœ¨çƒ­èº«â€¦â€¦

ä½†ç°åœ¨ä½ ç»ˆäºå¯ä»¥å¤§å±•æ‹³è„šäº†ï¼

åœ¨æ¥ä¸‹æ¥çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä»¥è‡´ç”¨ï¼Œæµ‹è¯•ä¸€äº›å¾ˆé…·çš„ä¸œè¥¿ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å°†æµ‹è¯•ä¸€ä¸ªåœºæ™¯ï¼Œå…¶ä¸­ Alice åªéœ€ä¸€æ­¥å°±å¯ä»¥å°†å¥¹çš„ ERC721 ä»£å¸è½¬ç§»ç»™ Bobã€‚

æˆ‘ä»¬çš„æµ‹è¯•å°†è¿™æ ·æ¥åšï¼š

-   ä¸º Alice åˆ›å»ºä¸€ä¸ªæ–°åƒµå°¸ï¼ˆè®°ä½ï¼Œåƒµå°¸ä¸è¿‡æ˜¯ä¸€ä¸ª ERC721 ä»£å¸è€Œå·²ï¼‰ã€‚

-   ç¡®ä¿ Alice å°†å¥¹çš„ ERC721 ä»£å¸è½¬ç§»ç»™ Bobã€‚

-   æ­¤æ—¶ï¼ŒBob åº”è¯¥æœ‰é‚£ä¸ª ERC721 ä»£å¸äº†ã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œ`ownerOf` å°†è¿”å›ä¸€ä¸ªç­‰äº Bob åœ°å€çš„å€¼ã€‚

-   å¿«æ”¶å°¾äº†ï¼Œè®©æˆ‘ä»¬åœ¨ä¸€ä¸ª`æ–­è¨€`ä¸­æ£€æŸ¥ Bob æ˜¯å¦æ˜¯ `newOwner`ã€‚

# å®æˆ˜æ¼”ä¹ 

1.  å‡½æ•°çš„ç¬¬ä¸€è¡Œåº”è¯¥è°ƒç”¨ `createPseudoRandomZombie`ã€‚ç»™å®ƒèµ·åä¸º`zombieNames[0]`ï¼Œå¹¶ç¡®ä¿ Alice æ˜¯å®ƒçš„ä¸»äººã€‚

2.  ç¬¬äºŒè¡Œåº”è¯¥å£°æ˜ä¸€ä¸ªå«åš `zombieId` çš„ `const`ï¼Œå¹¶å°†å®ƒèµ‹å€¼ä¸ºè¯¥åƒµå°¸çš„ idã€‚å¦‚æœéœ€è¦ï¼Œè¯·åˆ·æ–°æ‚¨çš„è®°å¿†ã€‚åœ¨ç¬¬4ç« ï¼Œä½ å­¦ä¹ äº†å¦‚ä½•æ£€ç´¢è¿™æ¡ä¿¡æ¯ã€‚å¦‚æœéœ€è¦ï¼Œå¯ä»¥å¤ä¹ å›é¡¾ä¸€ä¸‹ã€‚

3.  ç„¶åï¼Œæˆ‘ä»¬è¦ä»¥ `alice` å’Œ `bob` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ¥è°ƒç”¨ `transferFrom`ã€‚ç¡®ä¿ Alice è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°ï¼Œç„¶åæˆ‘ä»¬`ç­‰å¾…`å®ƒå®Œæˆè¿è¡Œï¼Œå†è¿›è¡Œä¸‹ä¸€æ­¥ã€‚

4.  å£°æ˜ä¸€ä¸ªåä¸º `newOwner` çš„ `const`ã€‚å°†å®ƒèµ‹å€¼ä¸ºä½¿ç”¨ `zombieId` è°ƒç”¨çš„ `ownerOf`ã€‚

5.  æœ€åï¼Œæ£€æŸ¥ Bob æ˜¯å¦æ‹¥æœ‰è¿™ä¸ª ERC721 ä»£å¸ã€‚å°†å…¶æ”¾å…¥ä»£ç ä¸­ï¼Œæ„å‘³ç€æˆ‘ä»¬åº”è¯¥ä»¥ `newOwner` å’Œ `bob` ä¸ºå‚æ•°è¿è¡Œ `assert.equal`ï¼›

    >æ³¨æ„ï¼š`assert.equal(newOwner, bob)` å’Œ `assert.equal(bob, newOwner)` åŸºæœ¬ä¸Šæ˜¯ä¸€æ ·çš„ã€‚ä½†æˆ‘ä»¬çš„å‘½ä»¤è¡Œè§£é‡Šå™¨æ²¡é‚£ä¹ˆå…ˆè¿›ï¼Œæ‰€ä»¥åªæœ‰å½“ä½ é”®å…¥ç¬¬ä¸€ç§æ—¶ï¼Œå®ƒæ‰ä¼šè®¤ä¸ºæ˜¯æ­£ç¡®çš„ã€‚

6. æˆ‘è¯´è¿‡ä¸Šä¸€æ­¥å°±æ˜¯æœ€åä¸€æ­¥å—ï¼Ÿå‘ƒâ€¦â€¦ éª—ä½ çš„å•¦ã€‚æœ€åä¸€æ­¥æ˜¯é€šè¿‡åˆ é™¤ `x` æ¥â€œä¸è·³è¿‡â€ç¬¬ä¸€ä¸ªåœºæ™¯ã€‚

å”·ï¼ä¸å°‘ä»£ç å“¦ã€‚å¸Œæœ›ä½ éƒ½èƒ½å®Œæˆã€‚å¦‚æœé‡åˆ°é—®é¢˜ï¼Œè¯·ç‚¹å‡»â€œæ˜¾ç¤ºç­”æ¡ˆâ€ã€‚


ç°åœ¨æ¥è¿è¡Œ `truffle test`ï¼Œçœ‹çœ‹æˆ‘ä»¬çš„æ–°æµ‹è¯•æ˜¯å¦é€šè¿‡:

```bash
Contract: CryptoZombies
  âœ“ should be able to create a new zombie (146ms)
  âœ“ should not allow two zombies (235ms)
  with the single-step transfer scenario
    âœ“ should transfer a zombie (382ms)
  with the two-step transfer scenario
    - should approve and then transfer a zombie when the owner calls transferForm
    - should approve and then transfer a zombie when the approved address calls transferForm


3 passing (1s)
2 pending
```

å¥½å˜ï¼æˆ‘ä»¬çš„ä»£ç é¡ºåˆ©é€šè¿‡äº†æµ‹è¯• ğŸ‘ğŸ»ã€‚

ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å¼€å§‹ä¸¤æ­¥åœºæ™¯ï¼Œå…¶ä¸­`approve` åé¢è·Ÿç€ `transferFrom`ã€‚
