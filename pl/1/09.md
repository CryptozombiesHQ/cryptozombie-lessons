---
title: Zombie Transfers- Single Step Scenario
actions:
  - 'checkAnswer'
  - 'hints'
requireLogin: true
material:
  editor:
    language: javascript
    startingCode:
      "test/CryptoZombies.js": |
        const CryptoZombies = artifacts.require("CryptoZombies");
        const utils = require("./helpers/utils");
        const zombieNames = ["Zombie 1", "Zombie 2"];
        contract("CryptoZombies", (accounts) => {
        let [alice, bob] = accounts;
        let contractInstance;
        beforeEach(async () => {
        contractInstance = await CryptoZombies.new();
        });
        it("should be able to create a new zombie", async () => {
        const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        assert.equal(result.receipt.status, true);
        assert.equal(result.logs[0].args.name,zombieNames[0]);
        })
        it("should not allow two zombies", async () => {
        await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice}));
        })
        xcontext("with the single-step transfer scenario", async () => {
        it("should transfer a zombie", async () => {
        // start here.
        })
        })
        xcontext("with the two-step transfer scenario", async () => {
        it("should approve and then transfer a zombie when the approved address calls transferForm", async () => {
        // TODO: Test the two-step scenario.  The approved address calls transferFrom
        })
        it("should approve and then transfer a zombie when the owner calls transferForm", async () => {
        // TODO: Test the two-step scenario.  The owner calls transferFrom
        })
        })
        })
      "test/helpers/utils.js": |
        async function shouldThrow(promise) {
        try {
        await promise;
        assert(true);
        }
        catch (err) {
        return;
        }
        assert(false, "The contract did not throw.");

        }

        module.exports = {
        shouldThrow,
        };
    answer: >
      const CryptoZombies = artifacts.require("CryptoZombies");
      const utils = require("./helpers/utils");
      const zombieNames = ["Zombie 1", "Zombie 2"];
      contract("CryptoZombies", (accounts) => { let [alice, bob] = accounts; let contractInstance; beforeEach(async () => { contractInstance = await CryptoZombies.new(); }); it("should be able to create a new zombie", async () => { const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice}); assert.equal(result.receipt.status, true); assert.equal(result.logs[0].args.name,zombieNames[0]); }) it("should not allow two zombies", async () => { await contractInstance.createRandomZombie(zombieNames[0], {from: alice}); await utils.shouldThrow(contractInstance.createRandomZombie(zombieNames[1], {from: alice})); }) context("with the single-step transfer scenario", async () => { it("should transfer a zombie", async () => { const result = await contractInstance.createRandomZombie(zombieNames[0], {from: alice}); const zombieId = result.logs[0].args.zombieId.toNumber(); await contractInstance.transferFrom(alice, bob, zombieId, {from: alice}); const newOwner = await contractInstance.ownerOf(zombieId); assert.equal(newOwner, bob); }) }) xcontext("with the two-step transfer scenario", async () => { it("should approve and then transfer a zombie when the approved address calls transferForm", async () => { // TODO: Test the two-step scenario.  The approved address calls transferFrom }) it("should approve and then transfer a zombie when the owner calls transferForm", async () => { // TODO: Test the two-step scenario.  The owner calls transferFrom }) }) })
---

So far weâ€™ve merely been warming up...

But now it's time to really show off what you know!

In the next chapters, we're going to be putting what weâ€™ve learned together and test something really cool.

To begin with, we're going to be testing the scenario in which _Alice_ transfers her zombie to _Bob_, in a single step.

Here is what our test should do:

-   Create a new zombie for Alice.

-   Make it so that Alice transfers her zombie to Bob.

-   At this point, Bob should own the zombie. If so, `ownerOf` would return a value that is equal to Bob's address.

-   Let's wrap it up by checking if Bob is the `newOwner`, inside an `assert`.


# Put it to the test

1.  The first line of the function should call `createRandomZombie`. Give it `zombieNames[0]` as the name and make sure Alice is the owner.

2.  The second line should declare a `const` named `zombieId` and set it equal to the zombie's id. In Chapter 4, you learned how to retrieve this piece of information. Refresh your memory, if needed.

3.  Then, we have to call `transferFrom` with `alice` and `bob` as the first parameters. Make sure Alice calls this function and we're `await`ing for it to finish running before moving to the next step.

4.  Declare a `const` called `newOwner`. Set it equal to `ownerOf` called with `zombieId`.

5.  Lastly, let's check whether Bob owns this zombie. Putting this into code, it means we should run `assert.equal` with `newOwner` and  `bob` as parameters;
> Note: `assert.equal(newOwner, bob)` and `assert.equal(bob, newOwner)` are basically the same thing. But our command line interpreter is not too advanced, so it won't consider your answer correct unless you type the first option.

6. Did I say the previous step is the last one! Well... it was a lie. The last thing we want to do is to "unskip" the first scenario by removing the `x`.

Phew! That's a lot of code. Hope you manage to get it right. If not, feel free to click "show answer".


Now let's run `truffle test` and see if our new test passes:

```bash
Contract: CryptoZombies
  âœ“ should be able to create a new zombie (146ms)
  âœ“ should not allow two zombies (235ms)
  with the single-step transfer scenario
    âœ“ should transfer a zombie (382ms)
  with the two-step transfer scenario
    - should approve and then transfer a zombie when the owner calls transferForm
    - should approve and then transfer a zombie when the approved address calls transferForm


3 passing (1s)
2 pending
```

And there it is! Our code passed the test with flying colorsğŸ‘ğŸ».

In the next chapter, we are going to move on to the 2 step scenario in which `approve` is followed by `transferFrom`.
