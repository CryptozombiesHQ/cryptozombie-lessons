---
title: –¢–æ–∫–µ–Ω—ã –Ω–∞ Ethereum
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "zombieownership.sol": |
        //  –ù–∞—á–∞–ª–æ –∑–¥–µ—Å—å
      "zombieattack.sol": |
        pragma solidity ^0.4.25;

        import "./zombiehelper.sol";

        contract ZombieAttack is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;

          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus;
          }

          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } else {
              myZombie.lossCount++;
              enemyZombie.winCount++;
              _triggerCooldown(myZombie);
            }
          }
        }

      "zombiehelper.sol": |
        pragma solidity ^0.4.25;

        import "./zombiefeeding.sol";

        contract ZombieHelper is ZombieFeeding {

          uint levelUpFee = 0.001 ether;

          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }

          function withdraw() external onlyOwner {
            address _owner = owner();
            _owner.transfer(address(this).balance);
          }

          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }

          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }

          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }

          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }

          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }

        }

      "zombiefeeding.sol": |
        pragma solidity ^0.4.25;

        import "./zombiefactory.sol";

        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }

        contract ZombieFeeding is ZombieFactory {

          KittyInterface kittyContract;

          modifier ownerOf(uint _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }

          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }

          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }

          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }

          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(abi.encodePacked(_species)) == keccak256(abi.encodePacked("kitty"))) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }

          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }

      "zombiefactory.sol": |
        pragma solidity ^0.4.25;

        import "./ownable.sol";

        contract ZombieFactory is Ownable {

            event NewZombie(uint zombieId, string name, uint dna);

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;

            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              uint16 winCount;
              uint16 lossCount;
            }

            Zombie[] public zombies;

            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;

            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                emit NewZombie(id, _name, _dna);
            }

            function _generatePseudoRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(abi.encodePacked(_str)));
                return rand % dnaModulus;
            }

            function createPseudoRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generatePseudoRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }

        }

      "ownable.sol": |
        pragma solidity ^0.4.25;

        /**
        * @title Ownable
        * @dev The Ownable contract has an owner address, and provides basic authorization control
        * functions, this simplifies the implementation of "user permissions".
        */
        contract Ownable {
          address private _owner;

          event OwnershipTransferred(
            address indexed previousOwner,
            address indexed newOwner
          );

          /**
          * @dev The Ownable constructor sets the original `owner` of the contract to the sender
          * account.
          */
          constructor() internal {
            _owner = msg.sender;
            emit OwnershipTransferred(address(0), _owner);
          }

          /**
          * @return the address of the owner.
          */
          function owner() public view returns(address) {
            return _owner;
          }

          /**
          * @dev Throws if called by any account other than the owner.
          */
          modifier onlyOwner() {
            require(isOwner());
            _;
          }

          /**
          * @return true if `msg.sender` is the owner of the contract.
          */
          function isOwner() public view returns(bool) {
            return msg.sender == _owner;
          }

          /**
          * @dev Allows the current owner to relinquish control of the contract.
          * @notice Renouncing to ownership will leave the contract without an owner.
          * It will not be possible to call the functions with the `onlyOwner`
          * modifier anymore.
          */
          function renounceOwnership() public onlyOwner {
            emit OwnershipTransferred(_owner, address(0));
            _owner = address(0);
          }

          /**
          * @dev Allows the current owner to transfer control of the contract to a newOwner.
          * @param newOwner The address to transfer ownership to.
          */
          function transferOwnership(address newOwner) public onlyOwner {
            _transferOwnership(newOwner);
          }

          /**
          * @dev Transfers control of the contract to a newOwner.
          * @param newOwner The address to transfer ownership to.
          */
          function _transferOwnership(address newOwner) internal {
            require(newOwner != address(0));
            emit OwnershipTransferred(_owner, newOwner);
            _owner = newOwner;
          }
        }

    answer: |
      pragma solidity ^0.4.25;

      import "./zombieattack.sol";

      contract ZombieOwnership is ZombieAttack {

      }
---

–î–∞–≤–∞–π—Ç–µ –ø–æ–≥–æ–≤–æ—Ä–∏–º –ø—Ä–æ **_—Ç–æ–∫–µ–Ω—ã_**.

–ï—Å–ª–∏ –≤—ã –±—ã–ª–∏ –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏ Ethereum –∫–∞–∫–æ–µ-—Ç–æ –≤—Ä–µ–º—è, –≤—ã, –≤–µ—Ä–æ—è—Ç–Ω–æ, —Å–ª—ã—à–∞–ª–∏, –∫–∞–∫ –ª—é–¥–∏ –≥–æ–≤–æ—Ä—è—Ç –æ —Ç–æ–∫–µ–Ω–∞—Ö ‚Äî¬†–æ—Å–æ–±–µ–Ω–Ω–æ **_ERC20 —Ç–æ–∫–µ–Ω–∞—Ö_**.

**_–¢–æ–∫–µ–Ω—ã_** –Ω–∞ Ethereum —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —É–º–Ω—ã–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–ª–µ–¥—É–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –æ–±—â–∏–º –ø—Ä–∞–≤–∏–ª–∞–º, –∞ –∏–º–µ–Ω–Ω–æ —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –Ω–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Å–ª–µ–¥—É—é—Ç –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã —Ç–æ–∫–µ–Ω–æ–≤, —Ç–∞–∫–∏–µ –∫–∞–∫ `transferFrom(address _from, address _to, uint256 _tokenId)` –∏ `balanceOf(address _owner)`.

–í–Ω—É—Ç—Ä–∏ —É–º–Ω—ã–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç –æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, `mapping(address => uint256) balances`, –∫–æ—Ç–æ—Ä–æ–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –±–∞–ª–∞–Ω—Å –∫–∞–∂–¥–æ–≥–æ –∞–¥—Ä–µ—Å–∞.

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –ø–æ —Å—É—Ç–∏ —Ç–æ–∫–µ–Ω - —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç, —É –∫–æ–≥–æ —Å–∫–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω–æ–≤, –∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏–π, –ø–æ–∑–≤–æ–ª—è—é—â–∏–µ —ç—Ç–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Å–≤–æ–∏ —Ç–æ–∫–µ–Ω—ã –Ω–∞ –¥—Ä—É–≥–∏–µ –∞–¥—Ä–µ—Å–∞.

### –ü–æ—á–µ–º—É —ç—Ç–æ —Ç–∞–∫ –≤–∞–∂–Ω–æ?

–ü–æ—Å–∫–æ–ª—å–∫—É –≤—Å–µ —Ç–æ–∫–µ–Ω—ã ERC20 –∏–º–µ—é—Ç –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –Ω–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏, —Å –Ω–∏–º–∏ –º–æ–∂–Ω–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤–æ.

–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –µ—Å–ª–∏ –≤—ã —Å–æ–∑–¥–∞–µ—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, —Å–ø–æ—Å–æ–±–Ω–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –æ–¥–Ω–∏–º —Ç–æ–∫–µ–Ω–æ–º ERC20, –æ–Ω–æ —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –ª—é–±—ã–º —Ç–æ–∫–µ–Ω–æ–º ERC20. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤ –±—É–¥—É—â–µ–º –≤ –≤–∞—à–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ —Ç–æ–∫–µ–Ω–æ–≤ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–π –¥–æ—Ä–∞–±–æ—Ç–∫–∏. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —Ç–æ–∫–µ–Ω–∞, –∏, –±—É–º, –≤ –≤–∞—à–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –µ—Å—Ç—å –µ—â–µ —Ç–æ–∫–µ–Ω, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å.

–û–¥–Ω–∏–º –∏–∑ –ø—Ä–∏–º–µ—Ä–æ–≤ —ç—Ç–æ–≥–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–∏—Ä–∂–∞. –ö–æ–≥–¥–∞ –±–∏—Ä–∂–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω ERC20, –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –µ–π –ø—Ä–æ—Å—Ç–æ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –µ—â–µ –æ–¥–∏–Ω —Å–º–∞—Ä—Ç-–∫–æ–Ω—Ç—Ä–∞–∫—Ç, —Å –∫–æ—Ç–æ—Ä—ã–º –æ–Ω–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É–µ—Ç. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç —Å–∫–∞–∑–∞—Ç—å —ç—Ç–æ–º—É –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –Ω–∞ –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –±–∏—Ä–∂–∏, –∞ –±–∏—Ä–∂–∞ –º–æ–∂–µ—Ç —Å–∫–∞–∑–∞—Ç—å –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –æ–±—Ä–∞—Ç–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º, –∫–æ–≥–¥–∞ –æ–Ω–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞—é—Ç –≤—ã–≤–æ–¥.

–ë–∏—Ä–∂–µ –Ω—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç—É –ª–æ–≥–∏–∫—É –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑, –∞ –∑–∞—Ç–µ–º, –∫–æ–≥–¥–∞ –æ–Ω —Ö–æ—á–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω ERC20, —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ –≤–æ–ø—Ä–æ—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∞–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –≤ –µ–µ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.

### –î—Ä—É–≥–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã —Ç–æ–∫–µ–Ω–æ–≤

ERC20 —Ç–æ–∫–µ–Ω—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ä–æ—à–∏ –¥–ª—è —Ç–æ–∫–µ–Ω–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤–µ–¥—É—Ç —Å–µ–±—è –∫–∞–∫ –≤–∞–ª—é—Ç—ã. –ù–æ –æ–Ω–∏ –Ω–µ –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω—ã –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∑–æ–º–±–∏ –≤ –Ω–∞—à–µ–π –∏–≥—Ä–µ –ø—Ä–æ –∑–æ–º–±–∏.

–í–æ-–ø–µ—Ä–≤—ã—Ö, –∑–æ–º–±–∏ –Ω–µ –¥–µ–ª–∏–º—ã, –∫–∞–∫ –≤–∞–ª—é—Ç—ã ‚Äî¬†—è –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –í–∞–º 0.237 ETH, –Ω–æ –æ—Ç–ø—Ä–∞–≤–∫–∞ –í–∞–º 0.237 –∑–æ–º–±–∏ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞.

–í–æ-–≤—Ç–æ—Ä—ã—Ö, –Ω–µ –≤—Å–µ –∑–æ–º–±–∏ —Å–æ–∑–¥–∞–Ω—ã —Ä–∞–≤–Ω—ã–º–∏. –í–∞—à –∑–æ–º–±–∏ 2 —É—Ä–æ–≤–Ω—è "**–°—Ç–∏–≤**" —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –Ω–µ —Ä–∞–≤–µ–Ω –º–æ–µ–º—É –∑–æ–º–±–∏ 732 —É—Ä–æ–≤–Ω—è "**H4XF13LD –ú–æ—Ä—Ä–∏—Å üíØüíØüòéüíØüíØ**". (–î–∞–∂–µ –Ω–µ –±–ª–∏–∑–∫–æ, *–°—Ç–∏–≤*).

–°—É—â–µ—Å—Ç–≤—É–µ—Ç –µ—â–µ –æ–¥–∏–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç —Ç–æ–∫–µ–Ω–æ–≤, –∫–æ—Ç–æ—Ä—ã–π –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –∫—Ä–∏–ø—Ç–æ-–∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, —Ç–∞–∫–∏—Ö –∫–∞–∫ –ö—Ä–∏–ø—Ç–æ–ó–æ–º–±–∏ ‚Äî¬†–∏ –æ–Ω–∏ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è **_ERC721 —Ç–æ–∫–µ–Ω—ã._**

**_ERC721 —Ç–æ–∫–µ–Ω—ã** **–Ω–µ** –≤–∑–∞–∏–º–æ–∑–∞–º–µ–Ω—è–µ–º—ã, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö —Å—á–∏—Ç–∞–µ—Ç—Å—è —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ –Ω–µ –¥–µ–ª–∏–º—ã–º. –í—ã –º–æ–∂–µ—Ç–µ –æ–±–º–µ–Ω—è—Ç—å –∏—Ö —Ç–æ–ª—å–∫–æ –∫–∞–∫ –æ–¥–Ω–æ —Ü–µ–ª–æ–µ, –∏ –∫–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö –∏–º–µ–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –¢–∞–∫ —á—Ç–æ –æ–Ω–∏ –∏–¥–µ–∞–ª—å–Ω–æ –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –Ω–∞—à–∏—Ö –∑–æ–º–±–∏ —É–¥–æ–±–Ω—ã–º–∏ –¥–ª—è –æ–±–º–µ–Ω–∞.

> –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç–∞–∫–æ–≥–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞, –∫–∞–∫ ERC721, –∏–º–µ–µ—Ç —Ç–æ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ, —á—Ç–æ –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –ª–æ–≥–∏–∫—É –∞—É–∫—Ü–∏–æ–Ω–∞ –∏–ª–∏ —É—Å–ª–æ–≤–Ω–æ–≥–æ –¥–µ–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (escrow) –≤ –Ω–∞—à–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ, –æ–ø—Ä–µ–¥–µ–ª—è—é—â—É—é, –∫–∞–∫ –∏–≥—Ä–æ–∫–∏ –º–æ–≥—É—Ç –æ–±–º–µ–Ω–∏–≤–∞—Ç—å / –ø—Ä–æ–¥–∞–≤–∞—Ç—å –Ω–∞—à–∏—Ö –∑–æ–º–±–∏. –ï—Å–ª–∏ –º—ã –±—É–¥–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏, –∫—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–π –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞—Ç—å –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –æ–±–º–µ–Ω–∞ –¥–ª—è –∫—Ä–∏–ø—Ç–æ-–æ–±–º–µ–Ω–Ω—ã—Ö –∞–∫—Ç–∏–≤–æ–≤ ERC721, –∏ –Ω–∞—à–∏ –∑–æ–º–±–∏ ERC721 –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —ç—Ç–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –µ—Å—Ç—å —è–≤–Ω—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞ —Ç–æ–∫–µ–Ω–æ–≤ –≤–º–µ—Å—Ç–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–∏ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏.

## –ü—Ä–æ–≤–µ—Ä—å —Å–µ–±—è

–ú—ã —Å–æ–±–∏—Ä–∞–µ–º—Å—è —É–≥–ª—É–±–∏—Ç—å—Å—è –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é ERC721 –≤ —Å–ª–µ–¥—É—é—â–µ–π –≥–ª–∞–≤–µ. –ù–æ —Å–Ω–∞—á–∞–ª–∞ –¥–∞–≤–∞–π—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª–æ–≤ –¥–ª—è —ç—Ç–æ–≥–æ —É—Ä–æ–∫–∞.

–ú—ã —Å–æ–±–∏—Ä–∞–µ–º—Å—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å—é –ª–æ–≥–∏–∫—É ERC721 –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º `ZombieOwnership`.

1. –û–±—ä—è–≤–∏—Ç–µ `pragma` –≤–µ—Ä—Å–∏—é –≤ –≤–µ—Ä—Ö—É —Ñ–∞–π–ª–∞ (–ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –≤ —Ñ–∞–π–ª–∞—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É—Ä–æ–∫–æ–≤).

2. –≠—Ç–æ—Ç —Ñ–∞–π–ª –¥–æ–ª–∂–µ–Ω –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å (`import`) –∫–æ–Ω—Ç—Ä–∞–∫—Ç `zombieattack.sol`.

3. –û–±—ä—è–≤–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç, `ZombieOwnership`, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Å–ª–µ–¥—É–µ—Ç—Å—è –æ—Ç `ZombieAttack`. –û—Å—Ç–∞–≤—å—Ç–µ —Ç–µ–ª–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –ø–æ–∫–∞ –ø—É—Å—Ç—ã–º.
