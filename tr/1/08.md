---
title: Using Try and Catch in JavaScript- Cont'd
actions:
  - 'checkAnswer'
  - 'hints'
requireLogin: true
material:
  editor:
    language: JavaScript
    startingCode:
      "EthPriceOracle.js": |
        const axios = require('axios')
        const BN = require('bn.js')
        const common = require('./utils/common.js')
        const SLEEP_INTERVAL = process.env.SLEEP_INTERVAL || 2000
        const PRIVATE_KEY_FILE_NAME = process.env.PRIVATE_KEY_FILE || './oracle/oracle_private_key'
        const CHUNK_SIZE = process.env.CHUNK_SIZE || 3
        const MAX_RETRIES = process.env.MAX_RETRIES || 5
        const OracleJSON = require('./oracle/build/contracts/EthPriceOracle.json')
        var pendingRequests = []

        async function getOracleContract (web3js) {
        const networkId = await web3js.eth.net.getId()
        return new web3js.eth.Contract(OracleJSON.abi, OracleJSON.networks[networkId].address)
        }

        async function filterEvents (oracleContract, web3js) {
        oracleContract.events.GetLatestEthPriceEvent(async (err, event) => {
        if (err) {
        console.error('Error on event', err)
        return
        }
        await addRequestToQueue(event)
        })

        oracleContract.events.SetLatestEthPriceEvent(async (err, event) => {
        if (err) console.error('Error on event', err)
        // Do something
        })
        }

        async function addRequestToQueue (event) {
        const callerAddress = event.returnValues.callerAddress
        const id = event.returnValues.id
        pendingRequests.push({ callerAddress, id })
        }

        async function processQueue (oracleContract, ownerAddress) {
        let processedRequests = 0
        while (pendingRequests.length > 0 && processedRequests < CHUNK_SIZE) {
        const req = pendingRequests.shift()
        await processRequest(oracleContract, ownerAddress, req.id, req.callerAddress)
        processedRequests++
        }
        }

        async function processRequest (oracleContract, ownerAddress, id, callerAddress) {
        let retries = 0
        while (retries < MAX_RETRIES) {
        try {
        const ethPrice = await retrieveLatestEthPrice()
        await setLatestEthPrice(oracleContract, callerAddress, ownerAddress, ethPrice, id)
        return
        } catch (error) {
        // Start here
        }
        }
        }
      "utils/common.js": |
        const fs = require('fs')
        const Web3 = require('web3')
        const { Client, NonceTxMiddleware, SignedTxMiddleware, LocalAddress, CryptoUtils, LoomProvider } = require('loom-js')

        function loadAccount (privateKeyFileName) {
        const extdevChainId = 'extdev-plasma-us1'
        const privateKeyStr = fs.readFileSync(privateKeyFileName, 'utf-8')
        const privateKey = CryptoUtils.B64ToUint8Array(privateKeyStr)
        const publicKey = CryptoUtils.publicKeyFromPrivateKey(privateKey)
        const client = new Client(
        extdevChainId,
        'wss://extdev-plasma-us1.dappchains.com/websocket',
        'wss://extdev-plasma-us1.dappchains.com/queryws'
        )
        client.txMiddleware = [
        new NonceTxMiddleware(publicKey, client),
        new SignedTxMiddleware(privateKey)
        ]
        client.on('error', msg => {
        console.error('Connection error', msg)
        })
        return {
        ownerAddress: LocalAddress.fromPublicKey(publicKey).toString(),
        web3js: new Web3(new LoomProvider(client, privateKey)),
        client
        }
        }

        module.exports = {
        loadAccount,
        };
      "oracle/EthPriceOracle.sol": |
        pragma solidity 0.5.0;
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        import "./CallerContractInterface.sol";
        contract EthPriceOracle is Ownable {
        uint private randNonce = 0;
        uint private modulus = 1000;
        mapping(uint256=>bool) pendingRequests;
        event GetLatestEthPriceEvent(address callerAddress, uint id);
        event SetLatestEthPriceEvent(uint256 ethPrice, address callerAddress);
        function getLatestEthPrice() public returns (uint256) {
        randNonce++;
        uint id = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % modulus;
        pendingRequests[id] = true;
        emit GetLatestEthPriceEvent(msg.sender, id);
        return id;
        }
        function setLatestEthPrice(uint256 _ethPrice, address _callerAddress, uint256 _id) public onlyOwner {
        require(pendingRequests[_id], "This request is not in my pending list.");
        delete pendingRequests[_id];
        CallerContracInterface callerContractInstance;
        callerContractInstance = CallerContracInterface(_callerAddress);
        callerContractInstance.callback(_ethPrice, _id);
        emit SetLatestEthPriceEvent(_ethPrice, _callerAddress);
        }
        }
      "caller/CallerContract.sol": |
        pragma solidity 0.5.0;
        import "./EthPriceOracleInterface.sol";
        import "openzeppelin-solidity/contracts/ownership/Ownable.sol";
        contract CallerContract is Ownable {
        uint256 private ethPrice;
        EthPriceOracleInterface private oracleInstance;
        address private oracleAddress;
        mapping(uint256=>bool) myRequests;
        event newOracleAddressEvent(address oracleAddress);
        event ReceivedNewRequestIdEvent(uint256 id);
        event PriceUpdatedEvent(uint256 ethPrice, uint256 id);
        function setOracleInstanceAddress (address _oracleInstanceAddress) public onlyOwner {
        oracleAddress = _oracleInstanceAddress;
        oracleInstance = EthPriceOracleInterface(oracleAddress);
        emit newOracleAddressEvent(oracleAddress);
        }
        function updateEthPrice() public {
        uint256 id = oracleInstance.getLatestEthPrice();
        myRequests[id] = true;
        emit ReceivedNewRequestIdEvent(id);
        }
        function callback(uint256 _ethPrice, uint256 _id) public onlyOracle {
        require(myRequests[_id], "This request is not in my pending list.");
        ethPrice = _ethPrice;
        delete myRequests[_id];
        emit PriceUpdatedEvent(_ethPrice, _id);
        }
        modifier onlyOracle() {
        require(msg.sender == oracleAddress, "You are not authorized to call this function.");
        _;
        }
        }
      "caller/EthPriceOracleInterface.sol": |
        pragma solidity 0.5.0;
        contract EthPriceOracleInterface {
        function getLatestEthPrice() public returns (uint256);
        }
      "oracle/CallerContractInterface.sol": |
        pragma solidity 0.5.0;
        contract CallerContracInterface {
        function callback(uint256 _ethPrice, uint256 id) public;
        }
    answer: |
      const axios = require('axios')
      const BN = require('bn.js')
      const common = require('./utils/common.js')
      const SLEEP_INTERVAL = process.env.SLEEP_INTERVAL || 2000
      const PRIVATE_KEY_FILE_NAME = process.env.PRIVATE_KEY_FILE || './oracle/oracle_private_key'
      const CHUNK_SIZE = process.env.CHUNK_SIZE || 3
      const MAX_RETRIES = process.env.MAX_RETRIES || 5
      const OracleJSON = require('./oracle/build/contracts/EthPriceOracle.json')
      var pendingRequests = []

      async function getOracleContract (web3js) {
      const networkId = await web3js.eth.net.getId()
      return new web3js.eth.Contract(OracleJSON.abi, OracleJSON.networks[networkId].address)
      }

      async function filterEvents (oracleContract, web3js) {
      oracleContract.events.GetLatestEthPriceEvent(async (err, event) => {
      if (err) {
      console.error('Error on event', err)
      return
      }
      await addRequestToQueue(event)
      })

      oracleContract.events.SetLatestEthPriceEvent(async (err, event) => {
      if (err) console.error('Error on event', err)
      // Do something
      })
      }

      async function addRequestToQueue (event) {
      const callerAddress = event.returnValues.callerAddress
      const id = event.returnValues.id
      pendingRequests.push({ callerAddress, id })
      }

      async function processQueue (oracleContract, ownerAddress) {
      let processedRequests = 0
      while (pendingRequests.length > 0 && processedRequests < CHUNK_SIZE) {
      const req = pendingRequests.shift()
      await processRequest(oracleContract, ownerAddress, req.id, req.callerAddress)
      processedRequests++
      }
      }

      async function processRequest (oracleContract, ownerAddress, id, callerAddress) {
      let retries = 0
      while (retries < MAX_RETRIES) {
      try {
      const ethPrice = await retrieveLatestEthPrice()
      await setLatestEthPrice(oracleContract, callerAddress, ownerAddress, ethPrice, id)
      return
      } catch (error) {
      if (retries === MAX_RETRIES - 1) {
      await setLatestEthPrice(oracleContract, callerAddress, ownerAddress, '0', id)
      return
      }
      retries++
      }
      }
      }
---

Great, you've finished coding the `try` blockðŸ’ªðŸ»! Now, let's move to the `catch` block. Remember, these lines of code are executed if an exception is thrown in the `try` block.

The logic looks something like this:

* First, you'd want to determine if the maximum number of retries has been reached. To do so, you'll use an `if` statement similar to the one below:
  ```JavaScript
  if (condition) {
    doSomething()
  }
  ```

* If `condition` evaluates to `true`, meaning that the maximum number of retries has been reached, then you'd want to notify the contract that something happened, and the oracle can't return a valid response. The simplest way to do this is to call the `setLatestEthPrice` and pass it `0` as the ETH price.
* If `condition` evaluates to `false`, meaning that the maximum number of requests has not been reached, you'd just have to increment the number of retries.

This logic can be implemented in just a few lines of code. Let's make the following changes.

## Put It to the Test

1. Remember that the `retries` variable starts counting with the number `0`. Add an if statement comparing `retries` and `MAX_RETRIES - 1`. This is JavaScript, so let's use the strict comparison operator (`===`).
2. Inside of the `if` statement, run the `setLatestEthPrice` method just like you did in the previous chapter. Make sure you pass it `'0'` instead of `ethPrice`.
3. If the maximum number of retries has been reached, the next line should just `return`.
4. Outside of the `if` statement, use `++` to increment the `retries` variable.
