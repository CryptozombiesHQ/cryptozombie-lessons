---
title: ì´ë”ë¦¬ì›€ ìƒì˜ í† í°
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "zombieownership.sol": |
        // ì—¬ê¸°ì„œ ì‹œì‘í•˜ê²Œ
      "zombieattack.sol": |
        pragma solidity ^0.4.19;

        import "./zombiehelper.sol";

        contract ZombieAttack is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;

          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }

          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } else {
              myZombie.lossCount++;
              enemyZombie.winCount++;
              _triggerCooldown(myZombie);
            }
          }
        }
      "zombiehelper.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefeeding.sol";

        contract ZombieHelper is ZombieFeeding {

          uint levelUpFee = 0.001 ether;

          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }

          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }

          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }

          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }

          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }

          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }

          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }

        }
      "zombiefeeding.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefactory.sol";

        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }

        contract ZombieFeeding is ZombieFactory {

          KittyInterface kittyContract;

          modifier ownerOf(uint _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }

          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }

          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }

          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }

          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }

          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
      "zombiefactory.sol": |
        pragma solidity ^0.4.19;

        import "./ownable.sol";

        contract ZombieFactory is Ownable {

            event NewZombie(uint zombieId, string name, uint dna);

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;

            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              uint16 winCount;
              uint16 lossCount;
            }

            Zombie[] public zombies;

            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;

            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }

            function _generatePseudoRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }

            function createPseudoRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generatePseudoRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }

        }
      "ownable.sol": |
        /**
         * @title Ownable
         * @dev The Ownable contract has an owner address, and provides basic authorization control
         * functions, this simplifies the implementation of "user permissions".
         */
        contract Ownable {
          address public owner;

          event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

          /**
           * @dev The Ownable constructor sets the original `owner` of the contract to the sender
           * account.
           */
          function Ownable() public {
            owner = msg.sender;
          }


          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
            require(msg.sender == owner);
            _;
          }


          /**
           * @dev Allows the current owner to transfer control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function transferOwnership(address newOwner) public onlyOwner {
            require(newOwner != address(0));
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
          }

        }
    answer: |
      pragma solidity ^0.4.19;

      import "./zombieattack.sol";
      
      contract ZombieOwnership is ZombieAttack {

      }
---

**_í† í°_**ì— ëŒ€í•´ì„œ ì–˜ê¸°í•´ë³´ì§€.

ìë„¤ê°€ ì´ë”ë¦¬ì›€ ì„¸ìƒì„ ì¡°ê¸ˆì´ë¼ë„ ì ‘í•œ ì ì´ ìˆë‹¤ë©´, ì‚¬ëŒë“¤ì´ í† í°ì— ëŒ€í•´ ì´ì•¼ê¸°í•˜ëŠ” ê²ƒì„ ë“¤ì–´ë´¤ì„ ìˆ˜ë„ ìˆì„ ê²ƒì´ë„¤ - êµ¬ì²´ì ìœ¼ë¡œëŠ” **_ERC20 í† í°**ì— ëŒ€í•´ì„œ ë§ì´ë„¤.

ì´ë”ë¦¬ì›€ì—ì„œ **_í† í°_**ì€ ê¸°ë³¸ì ìœ¼ë¡œ ê·¸ì € ëª‡ëª‡ ê³µí†µ ê·œì•½ì„ ë”°ë¥´ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì´ë„¤ â€”Â ì¦‰ ë‹¤ë¥¸ ëª¨ë“  í† í° ì»¨íŠ¸ë™íŠ¸ê°€ ì‚¬ìš©í•˜ëŠ” í‘œì¤€ í•¨ìˆ˜ ì§‘í•©ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì´ì§€. ì˜ˆë¥¼ ë“¤ë©´ `transfer(address _to, uint256 _value)`ë‚˜ `balanceOf(address _owner)` ê°™ì€ í•¨ìˆ˜ë“¤ì´ ìˆë„¤.

ë‚´ë¶€ì ìœ¼ë¡œ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ëŠ” ë³´í†µ `mapping(address => uint256) balances`ì™€ ê°™ì€ ë§¤í•‘ì„ ê°€ì§€ê³  ìˆë„¤. ê°ê°ì˜ ì£¼ì†Œì— ì”ì•¡ì´ ì–¼ë§ˆë‚˜ ìˆëŠ”ì§€ ê¸°ë¡í•˜ëŠ” ê²ƒì´ì§€.

ì¦‰ ê¸°ë³¸ì ìœ¼ë¡œ í† í°ì€ ê·¸ì € í•˜ë‚˜ì˜ ì»¨íŠ¸ë™íŠ¸ì´ë„¤. ê·¸ ì•ˆì—ì„œ ëˆ„ê°€ ì–¼ë§ˆë‚˜ ë§ì€ í† í°ì„ ê°€ì§€ê³  ìˆëŠ”ì§€ ê¸°ë¡í•˜ê³ , ëª‡ëª‡ í•¨ìˆ˜ë¥¼ ê°€ì§€ê³  ì‚¬ìš©ìë“¤ì´ ê·¸ë“¤ì˜ í† í°ì„ ë‹¤ë¥¸ ì£¼ì†Œë¡œ ì „ì†¡í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ê²ƒì´ì§€.

### ì™œ ì´ë ‡ê²Œ í•´ì•¼ í•˜ë‚˜ìš”?

ëª¨ë“  ERC20 í† í°ë“¤ì´ ë˜‘ê°™ì€ ì´ë¦„ì˜ ë™ì¼í•œ í•¨ìˆ˜ ì§‘í•©ì„ ê³µìœ í•˜ê¸° ë•Œë¬¸ì—, ì´ í† í°ë“¤ì— ë˜‘ê°™ì€ ë°©ì‹ìœ¼ë¡œ ìƒí˜¸ì‘ìš©ì´ ê°€ëŠ¥í•˜ë„¤.

ì¦‰ ìë„¤ê°€ í•˜ë‚˜ì˜ ERC20 í† í°ê³¼ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ í•˜ë‚˜ë¥¼ ë§Œë“¤ë©´, ì´ ì•±ì´ ë‹¤ë¥¸ ì–´ë–¤ ERC20 í† í°ê³¼ë„ ìƒí˜¸ì‘ìš©ì´ ê°€ëŠ¥í•œ ê²ƒì´ì§€. ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ìë„¤ì˜ ì•±ì— ë” ë§ì€ í† í°ë“¤ì„ ì¶”ê°€í•  ìˆ˜ ìˆì§€. ì»¤ìŠ¤í…€ ì½”ë“œë¥¼ ì¶”ê°€í•˜ì§€ ì•Šê³ ë„ ë§ì´ë„¤. ìë„¤ëŠ” ê·¸ì € ìƒˆë¡œìš´ í† í°ì˜ ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œë§Œ ë¼ì›Œë„£ìœ¼ë©´ ë˜ë„¤. ê·¸ëŸ¬ê³  ë‚˜ë©´, ì§ , ìë„¤ì˜ ì•±ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë˜ ë‹¤ë¥¸ í† í°ì´ ìƒê¸°ëŠ” ê²ƒì´ë„¤.

ì´ëŸ¬í•œ ê²ƒì˜ í•œ ì˜ˆë¡œëŠ” ê±°ë˜ì†Œê°€ ìˆë„¤. í•œ ê±°ë˜ì†Œì—ì„œ ìƒˆë¡œìš´ ERC20 í† í°ì„ ìƒì¥í•  ë•Œ, ì‹¤ì œë¡œëŠ” ì´ ê±°ë˜ì†Œì—ì„œ í†µì‹ ì´ ê°€ëŠ¥í•œ ë˜ í•˜ë‚˜ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì´ë„¤. ì‚¬ìš©ìë“¤ì€ ì´ ì»¨íŠ¸ë™íŠ¸ì— ê±°ë˜ì†Œì˜ ì§€ê°‘ ì£¼ì†Œì— í† í°ì„ ë³´ë‚´ë¼ê³  í•  ìˆ˜ ìˆê³ , ê±°ë˜ì†Œì—ì„œëŠ” ì´ ì»¨íŠ¸ë™íŠ¸ì— ì‚¬ìš©ìë“¤ì´ ì¶œê¸ˆì„ ì‹ ì²­í•˜ë©´ í† í°ì„ ë‹¤ì‹œ ëŒë ¤ë³´ë‚´ë¼ê³  í•  ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ê²ƒì´ì§€.

ê±°ë˜ì†Œì—ì„œëŠ” ì´ ì „ì†¡ ë¡œì§ì„ í•œ ë²ˆë§Œ êµ¬í˜„í•˜ë©´ ë˜ë„¤. ê·¸ë¦¬ê³ ì„œ ìƒˆë¡œìš´ ERC20 í† í°ì„ ì¶”ê°€í•˜ê³  ì‹¶ìœ¼ë©´, ë°ì´í„°ë² ì´ìŠ¤ì— ë‹¨ìˆœíˆ ìƒˆ ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œë¥¼ ì¶”ê°€í•˜ê¸°ë§Œ í•˜ë©´ ë˜ëŠ” ì¼ì´ì§€.

### ë‹¤ë¥¸ í† í° í‘œì¤€

ERC20 í† í°ì€ í™”íì²˜ëŸ¼ ì‚¬ìš©ë˜ëŠ” í† í°ìœ¼ë¡œëŠ” ì •ë§ ì ì ˆí•˜ë„¤. í•˜ì§€ë§Œ ìš°ë¦¬ì˜ ì¢€ë¹„ ê²Œì„ì—ì„œ ì¢€ë¹„ë¥¼ í‘œí˜„í•  ë•Œì—ëŠ” ê·¸ë‹¤ì§€ ì“¸ëª¨ ìˆì§€ê°€ ì•Šì§€.

ì²«ì§¸ë¡œ, ì¢€ë¹„ëŠ” í™”íì²˜ëŸ¼ ë¶„í• í•  ìˆ˜ê°€ ì—†ë„¤ - ë‚œ ìë„¤ì—ê²Œ 0.237ETHë¥¼ ë³´ë‚¼ ìˆ˜ ìˆì§€ë§Œ, ìë„¤ì—ê²Œ 0.237ê°œì˜ ì¢€ë¹„ë¥¼ ë³´ë‚´ëŠ” ê²ƒì€ ë§ì´ ë˜ì§€ ì•Šì§€.

ë‘˜ì§¸ë¡œ, ëª¨ë“  ì¢€ë¹„ê°€ ë˜‘ê°™ì§€ëŠ” ì•Šë„¤. ìë„¤ì˜ ë ˆë²¨2 ì¢€ë¹„ "**Steve**"ëŠ” ë‚´ ë ˆë²¨732 ì¢€ë¹„ "**H4XF13LD MORRIS ğŸ’¯ğŸ’¯ğŸ˜ğŸ’¯ğŸ’¯**"ì™€ëŠ” ì™„ì „íˆ ë‹¤ë¥´ì§€(*Steve*ì™€ëŠ” ë¹„êµí•  ìˆ˜ê°€ ì—†ì§€!).

ì—¬ê¸°ì— í¬ë¦½í† ì¢€ë¹„ì™€ ê°™ì€ í¬ë¦½í†  ìˆ˜ì§‘í’ˆì„ ìœ„í•´ ë” ì ì ˆí•œ í† í° í‘œì¤€ì´ ìˆë„¤ - ë°”ë¡œ **_ERC721 í† í°_**ì´ì§€.

**_ERC721 í† í°_**ì€ êµì²´ê°€ **ë¶ˆê°€**í•˜ë„¤. ê°ê°ì˜ í† í°ì´ ìœ ì¼í•˜ê³  ë¶„í• ì´ ë¶ˆê°€í•˜ê¸° ë•Œë¬¸ì´ì§€. ìë„¤ëŠ” ì´ í† í°ì„ í•˜ë‚˜ì˜ ì „ì²´ ë‹¨ìœ„ë¡œë§Œ ê±°ë˜í•  ìˆ˜ ìˆê³ , ê°ê°ì˜ í† í°ì€ ìœ ì¼í•œ IDë¥¼ ê°€ì§€ê³  ìˆë„¤. ê·¸ëŸ¬ë‹ˆ ì´ê²Œ ìš°ë¦¬ì˜ ì¢€ë¹„ë¥¼ ê±°ë˜í•  ìˆ˜ ìˆê²Œ í•˜ê¸°ì—ëŠ” ì•„ì£¼ ì ì ˆí•˜ì§€.

> ERC721ê³¼ ê°™ì€ í‘œì¤€ì„ ì‚¬ìš©í•˜ë©´ ìš°ë¦¬ì˜ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì‚¬ìš©ìë“¤ì´ ìš°ë¦¬ì˜ ì¢€ë¹„ë¥¼ ê±°ë˜/íŒë§¤í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²½ë§¤ë‚˜ ì¤‘ê³„ ë¡œì§ì„ ìš°ë¦¬ê°€ ì§ì ‘ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„ ëœë‹¤ëŠ” ì´ì ì´ ìˆë„¤. ìš°ë¦¬ê°€ ìŠ¤í™ì— ë§ì¶”ê¸°ë§Œ í•˜ë©´, ëˆ„êµ°ê°€ ERC721 ìì‚°ì„ ê±°ë˜í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê±°ë˜ì†Œ í”Œë«í¼ì„ ë§Œë“¤ë©´ ìš°ë¦¬ì˜ ERC721 ì¢€ë¹„ë“¤ì„ ê·¸ í”Œë«í¼ì—ì„œ ì“¸ ìˆ˜ ìˆê²Œ ë  ê²ƒì´ë„¤. ê·¸ëŸ¬ë‹ˆ ìë„¤ë§Œì˜ ê±°ë˜ ë¡œì§ì„ ë§Œë“œëŠë¼ ê³ ìƒí•˜ëŠ” ê²ƒë³´ë‹¤ í† í° í‘œì¤€ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ëª…í™•í•œ ì´ì ì´ ìˆëŠ” ê²ƒì´ì§€.

## ì§ì ‘ í•´ë³´ê¸°

ìš°ë¦¬ëŠ” ë‹¤ìŒ ì±•í„°ì—ì„œ ERC721ì„ êµ¬í˜„í•˜ê¸° ì‹œì‘í•  ê²ƒì´ë„¤. ê·¸ì „ì— ë¨¼ì €, ì´ë²ˆ ë ˆìŠ¨ì„ ìœ„í•œ íŒŒì¼ êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ ë³´ì„¸.

ìš°ë¦¬ëŠ” ëª¨ë“  ERC721 ë¡œì§ì„ `ZombieOwnership`ì´ë¼ëŠ” ì»¨íŠ¸ë™íŠ¸ì— ì €ì¥í•  ê²ƒì´ë„¤.

1. íŒŒì¼ì˜ ìµœìƒë‹¨ì— `pragma` ë²„ì „ì„ ì„ ì–¸í•˜ê²Œ(ë¬¸ë²•ì€ ì´ì „ ë ˆìŠ¨ì˜ íŒŒì¼ì—ì„œ ì°¸ê³ í•˜ê²Œ).

2. ì´ íŒŒì¼ì€ `zombieattack.sol`ì„ `import` í•´ì•¼ í•˜ë„¤.

3. `ZombieOwnership`ì´ë¼ëŠ” ìƒˆë¡œìš´ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì„ ì–¸í•˜ê³ , `ZombieAttack`ì„ ìƒì†í•˜ê²Œ. ì»¨íŠ¸ë™íŠ¸ì˜ ë‚´ìš©ì€ ì§€ê¸ˆ ë‹¹ì¥ì€ ë¹„ì›Œë‘ê²Œ.
