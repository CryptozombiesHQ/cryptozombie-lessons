---
title: Tokeny na Ethereu
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "zombieownership.sol": |
        // Za캜ni tu
      "zombieattack.sol": |
        pragma solidity ^0.4.19;

        import "./zombiehelper.sol";

        contract ZombieAttack is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;

          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }

          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } else {
              myZombie.lossCount++;
              enemyZombie.winCount++;
              _triggerCooldown(myZombie);
            }
          }
        }
      "zombiehelper.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefeeding.sol";

        contract ZombieHelper is ZombieFeeding {

          uint levelUpFee = 0.001 ether;

          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }

          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }

          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }

          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }

          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }

          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }

          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }

        }
      "zombiefeeding.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefactory.sol";

        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }

        contract ZombieFeeding is ZombieFactory {

          KittyInterface kittyContract;

          modifier ownerOf(uint _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }

          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }

          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }

          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }

          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }

          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
      "zombiefactory.sol": |
        pragma solidity ^0.4.19;

        import "./ownable.sol";

        contract ZombieFactory is Ownable {

            event NewZombie(uint zombieId, string name, uint dna);

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;

            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              uint16 winCount;
              uint16 lossCount;
            }

            Zombie[] public zombies;

            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;

            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }

            function _generatePseudoRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }

            function createPseudoRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generatePseudoRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }

        }
      "ownable.sol": |
        /**
         * @title Ownable
         * @dev The Ownable contract has an owner address, and provides basic authorization control
         * functions, this simplifies the implementation of "user permissions".
         */
        contract Ownable {
          address public owner;

          event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

          /**
           * @dev The Ownable constructor sets the original `owner` of the contract to the sender
           * account.
           */
          function Ownable() public {
            owner = msg.sender;
          }


          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
            require(msg.sender == owner);
            _;
          }


          /**
           * @dev Allows the current owner to transfer control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function transferOwnership(address newOwner) public onlyOwner {
            require(newOwner != address(0));
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
          }

        }
    answer: |
      pragma solidity ^0.4.19;

      import "./zombieattack.sol";
      
      contract ZombieOwnership is ZombieAttack {

      }
---

Po캞me sa porozpr치va콘 o **_tokenoch_**.

Ak si sa v oblasti Ethereum pohybuje코 u nejak칰 dobu, pravdepodobne si po캜ul 쬿d칤 캜asto spom칤na콘 r칪zne tokeny - hlavne **_ERC20 tokeny_**.

**_Token_** na Ethereu je v podstate smart kontrakt ktor칳 dodr쬿je ur캜it칠 spolo캜n칠 pravidl치 - presnej코ie, implementuje mno쬴nu funkci칤 ktor칠 su definovan칠 aj na kontraktoch v코etk칳ch ostatn칳ch ERC20 tokenov, ako napr칤klad `transfer(address _to, uint256 _value)` a `balanceOf(address _owner)`.

Interne tieto smart kontrakty obvykle pou쮂셨aj칰 mapovanie `mapping(address => uint256) balances` na to, aby si udr쬴avali preh쬬d o tom ktor칳 Ethereum 칰캜et m치 ko쬶o tokenov. 

Tak쬰 token je v podstate len smart kontrakt ktor칳 si dr쮂 preh쬬d o tom ktor치 adresa m치 ko쬶o tokenov, a implementuje funkcie ktor칠 umo쮄갓j칰 vlastn칤kom tokenov prev치dza콘 tieto tokeny na in칠 adresy. 

### Pre캜o na tom z치le쮂?

ERC20 tokeny zdie쬬j칰 mno쬴nu funkci칤 s toto쬹칳mi menami. Preto je mo쬹칠 so v코etk칳m ERC20 tokenmi pracova콘 rovnak칳m sp칪sobom.

To znamen치, 쬰 ak vytvor칤코 aplik치ciu ktor치 je schopn치 pracova콘 s ERC20 tokenom, bude schopn치 pracova콘 s so v코etk칳mi ostatn칳mi tokenmi implementuj칰cimi ERC20 코tandard. Ak sa preto v bud칰cnosti rozhodne코 vo svojej aplik치ci칤 za캜a콘 pou쮂셨a콘 nejak칠 캞al코ie ERC20 tokeny, nebude 콘a to st치콘 skoro 쬴adnu n치mahu. Proste vo svojej aplik치ci칤 nastav칤코 adresu ERC20 tokenu, a bum, tvoja aplik치cia pracuje s nov칳m tokenom.

Praktick칳m pr칤kladom toho s칰 crypto exchange. Ke캞 sa exchange rozhodne prida콘 nov칳 ERC20 token, je to pre nich jednoduch칠. Sta캜칤 im prida콘 do ich datab치zy adresu smart kontraktu reprezentuj칰ci dan칳 token. U쮂셨atelia m칪쬿 potom prostredn칤ctom rovnak칠ho kontraktu posla콘 tieto tokeny na adresu exchange. Naopak, ke캞 sa u쮂셨ate rozhodne tokeny si z exchange vytiahnu콘, exchange prostredn칤ctvom tohoto kontraktu po코le tokeny tam, kam si o to u쮂셨ate po쬴ada.

Exchange implementuj칰 logiku prenosu tokenov len raz. Ke캞 sa potom rozhodn칰 podporova콘 nov칳 ERC20 token, je to len z치le쬴tos콘 pridania novej adresy smart kontraktu do ich datab치z.  

### 캝al코ie token 코tandardy

ERC20 tokeny su fakt super, preto쬰 tokeny sa spr치vaj칰 ako meny. Tie by ale neboli ve쬸i u쬴to캜n칠 pre reprezent치ciu zombiekov v na코ej hre.

Za prv칠, zombie nie s칰 deliteln칳 ako meny. S칤ce niekomu m칪쬰코 posla콘 0.237 ETH, no odoslanie 237 tis칤cin tvojho zombie ned치va zmysel. 

Za druh칠, nie v코etci zombie s칰 si rovn칤. Tvoj Level 2 zombie "**Steve**" absol칰tne nie je rovn칳 m칪jmu Level 732 zombie "**H4XF13LD MORRIS 游눮游눮游땙游눮游눮**". (Nie, ani tro코ku, *Steve*)

Existuje in칳 token 코tandard, ktor칳 je ove쬬 vhodnej코칤 pre krypto zberatelsk칠 predmety (crypto-collectibles) ako s칰 CryptoZombies. S칰 to **_ERC721 tokeny_**.

**_ERC721 tokeny_** **NIE S칔** zamenite쬹칠, preto쬰 ka쬯칳 jeden z nich je pova쬺van칳 za unik치tny a 캞alej nedelite쬹칳. Je mo쬹칠 ich obchodova콘 v celkoch, ka쬯칳 ma unik치tne ID. S칰 preto perfektn칳m kandid치tom rie코enia, ako spravi콘 na코ich zombie obchodovate쬹칳ch.

> Uvedom si 쬰 pou쮂셨anie 코tandardu ako ERC721 m치 v칳hodu v tom 쬰 v r치mci na코eho kontraktu nemus칤me implementova콘 logiku aukci칤 a escrow, ktor치 by ur캜ovala ako m칪쬿 hr치캜i so svojimi zombie obchodova콘. Miesto toho niekto in칳 m칪쬰 vytvori콘 platformu na obchodovanie s ERC721 akt칤vami. Pokia s칰 potom na코i zomb칤ci v s칰lade s ERC721, bud칰 plne kompatibiln칳 s takouto obchodovacou platformou. Toto je jasn치 v칳hoda dodr쬴avania token 코tandardov miesto vym칳코lania vlastnej obchodovacej logiky.

## Vysk칰코aj si to s치m

V 캞al코ej kapitole sa ideme ponori콘 do implement치cie ERC721. Ale pred t칳m si po캞me pripravi콘 s칰bor s nov칳m kontraktom.

V코etku logiku spojen칰 s ERC721 budeme ma콘 v kontrakte n치zvom `ZombieOwnership`.

1. Na za캜iatku s칰boru deklaruj verziu `pragma` (pozri si s칰bory z predo코l칳ch lekci칤 pre zopakovanie syntaxe).

2. 캝alej sprav `import` s칰boru `zombieattack.sol`.

3. Deklaruj nov칳 kontrakt, `ZombieOwnership`, ktor칳 ded칤 od  `ZombieAttack`. Telo kontraktu ponechaj zatia pr치zdne.
