---
title: Tokeny na Ethereu
actions: ['checkAnswer', 'hints']
requireLogin: true
material:
  editor:
    language: sol
    startingCode:
      "zombieownership.sol": |
      // Zaƒçni tu
      "zombieattack.sol": |
        pragma solidity ^0.4.19;

        import "./zombiehelper.sol";

        contract ZombieAttack is ZombieHelper {
          uint randNonce = 0;
          uint attackVictoryProbability = 70;

          function randMod(uint _modulus) internal returns(uint) {
            randNonce++;
            return uint(keccak256(now, msg.sender, randNonce)) % _modulus;
          }

          function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            Zombie storage enemyZombie = zombies[_targetId];
            uint rand = randMod(100);
            if (rand <= attackVictoryProbability) {
              myZombie.winCount++;
              myZombie.level++;
              enemyZombie.lossCount++;
              feedAndMultiply(_zombieId, enemyZombie.dna, "zombie");
            } else {
              myZombie.lossCount++;
              enemyZombie.winCount++;
              _triggerCooldown(myZombie);
            }
          }
        }
      "zombiehelper.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefeeding.sol";

        contract ZombieHelper is ZombieFeeding {

          uint levelUpFee = 0.001 ether;

          modifier aboveLevel(uint _level, uint _zombieId) {
            require(zombies[_zombieId].level >= _level);
            _;
          }

          function withdraw() external onlyOwner {
            owner.transfer(this.balance);
          }

          function setLevelUpFee(uint _fee) external onlyOwner {
            levelUpFee = _fee;
          }

          function levelUp(uint _zombieId) external payable {
            require(msg.value == levelUpFee);
            zombies[_zombieId].level++;
          }

          function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].name = _newName;
          }

          function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) {
            zombies[_zombieId].dna = _newDna;
          }

          function getZombiesByOwner(address _owner) external view returns(uint[]) {
            uint[] memory result = new uint[](ownerZombieCount[_owner]);
            uint counter = 0;
            for (uint i = 0; i < zombies.length; i++) {
              if (zombieToOwner[i] == _owner) {
                result[counter] = i;
                counter++;
              }
            }
            return result;
          }

        }
      "zombiefeeding.sol": |
        pragma solidity ^0.4.19;

        import "./zombiefactory.sol";

        contract KittyInterface {
          function getKitty(uint256 _id) external view returns (
            bool isGestating,
            bool isReady,
            uint256 cooldownIndex,
            uint256 nextActionAt,
            uint256 siringWithId,
            uint256 birthTime,
            uint256 matronId,
            uint256 sireId,
            uint256 generation,
            uint256 genes
          );
        }

        contract ZombieFeeding is ZombieFactory {

          KittyInterface kittyContract;

          modifier ownerOf(uint _zombieId) {
            require(msg.sender == zombieToOwner[_zombieId]);
            _;
          }

          function setKittyContractAddress(address _address) external onlyOwner {
            kittyContract = KittyInterface(_address);
          }

          function _triggerCooldown(Zombie storage _zombie) internal {
            _zombie.readyTime = uint32(now + cooldownTime);
          }

          function _isReady(Zombie storage _zombie) internal view returns (bool) {
              return (_zombie.readyTime <= now);
          }

          function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) {
            Zombie storage myZombie = zombies[_zombieId];
            require(_isReady(myZombie));
            _targetDna = _targetDna % dnaModulus;
            uint newDna = (myZombie.dna + _targetDna) / 2;
            if (keccak256(_species) == keccak256("kitty")) {
              newDna = newDna - newDna % 100 + 99;
            }
            _createZombie("NoName", newDna);
            _triggerCooldown(myZombie);
          }

          function feedOnKitty(uint _zombieId, uint _kittyId) public {
            uint kittyDna;
            (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
            feedAndMultiply(_zombieId, kittyDna, "kitty");
          }
        }
      "zombiefactory.sol": |
        pragma solidity ^0.4.19;

        import "./ownable.sol";

        contract ZombieFactory is Ownable {

            event NewZombie(uint zombieId, string name, uint dna);

            uint dnaDigits = 16;
            uint dnaModulus = 10 ** dnaDigits;
            uint cooldownTime = 1 days;

            struct Zombie {
              string name;
              uint dna;
              uint32 level;
              uint32 readyTime;
              uint16 winCount;
              uint16 lossCount;
            }

            Zombie[] public zombies;

            mapping (uint => address) public zombieToOwner;
            mapping (address => uint) ownerZombieCount;

            function _createZombie(string _name, uint _dna) internal {
                uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;
                zombieToOwner[id] = msg.sender;
                ownerZombieCount[msg.sender]++;
                NewZombie(id, _name, _dna);
            }

            function _generateRandomDna(string _str) private view returns (uint) {
                uint rand = uint(keccak256(_str));
                return rand % dnaModulus;
            }

            function createRandomZombie(string _name) public {
                require(ownerZombieCount[msg.sender] == 0);
                uint randDna = _generateRandomDna(_name);
                randDna = randDna - randDna % 100;
                _createZombie(_name, randDna);
            }

        }
      "ownable.sol": |
        /**
         * @title Ownable
         * @dev The Ownable contract has an owner address, and provides basic authorization control
         * functions, this simplifies the implementation of "user permissions".
         */
        contract Ownable {
          address public owner;

          event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

          /**
           * @dev The Ownable constructor sets the original `owner` of the contract to the sender
           * account.
           */
          function Ownable() public {
            owner = msg.sender;
          }


          /**
           * @dev Throws if called by any account other than the owner.
           */
          modifier onlyOwner() {
            require(msg.sender == owner);
            _;
          }


          /**
           * @dev Allows the current owner to transfer control of the contract to a newOwner.
           * @param newOwner The address to transfer ownership to.
           */
          function transferOwnership(address newOwner) public onlyOwner {
            require(newOwner != address(0));
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
          }

        }
    answer: |
      pragma solidity ^0.4.19;

      import "./zombieattack.sol";
      
      contract ZombieOwnership is ZombieAttack {

      }
---

Poƒème sa porozpr√°va≈• o **_tokenoch_**.
Let's talk about **_tokens_**.

Ak si sa v oblasti Ethereum pohybuje≈° u≈æ nejak√∫ dobu, pravdepodobne si poƒçul ƒæud√≠ ƒçasto spom√≠na≈• r√¥zne tokeny - ≈°pecificky **_ERC20 tokeny_**.
If you've been in the Ethereum space for any amount of time, you've probably heard people talking about tokens ‚Äî¬†specifically **_ERC20 tokens_**.

**_Token_** na Ethereu je v podstate smart kontrakt ktor√Ω dodr≈æuje urƒçit√© spoloƒçn√© pravidl√° - presnej≈°ie, implementuje mno≈æinu funkci√≠ ktor√© su definovan√© aj na kontraktoch v≈°etk√Ωch ostatn√Ωch ERC20 tokenov, ako napr√≠klad `transfer(address _to, uint256 _value)` a `balanceOf(address _owner)`.
A **_token_** on Ethereum is basically just a smart contract that follows some common rules ‚Äî¬†namely it implements a standard set of functions that all other token contracts share, such as `transfer(address _to, uint256 _value)` and `balanceOf(address _owner)`.

Interne tieto smart kontrakty obvykle pou≈æ√≠vaj√∫ mapping, `mapping(address => uint256) balances`, na to aby si udr≈æiavali prehƒæad o tom ktor√Ω Ethereum √∫ƒçet m√° koƒæko tokenov. 
Internally the smart contract usually has a mapping, `mapping(address => uint256) balances`, that keeps track of how much balance each address has.

Tak≈æe token je v podstate len smart kontrakt, ktor√Ω si dr≈æ√≠ prehƒæad o tom kto m√° koƒæko tokenov, a implementuje funkcie ktor√© umo≈æ≈àuj√∫ vlastn√≠kom tokenov prev√°dza≈• tieto tokeny na in√© adresy. 
So basically a token is just a contract that keeps track of who owns how much of that token, and some functions so those users can transfer their tokens to other addresses.

### Preƒço na tom z√°le≈æ√≠?
### Why does it matter?

Nakoƒæko ERC20 tokeny zdieƒæaju mno≈æinu funkci√≠ s toto≈æn√Ωmi menami, so v≈°etk√Ωm ERC20 tokenmi je mo≈æn√© pracova≈• rovnak√Ωm sp√¥sobom.
Since all ERC20 tokens share the same set of functions with the same names, they can all be interacted with in the same ways.

To znamen√° ≈æe ak vytvor√≠≈° aplik√°ciu ktor√° je schopn√° pracova≈• s ERC20 tokenom, bude schopn√° pracova≈• s so v≈°etk√Ωmi tokenmi implementuj√∫cimi ERC20 ≈°tandard. T√Ωm p√°dom, ak sa v bud√∫cnosti rozhodne≈° vo svojej aplik√°ci√≠ zaƒça≈• pou≈æ√≠va≈• nejak√© ƒèal≈°ie tokeny, nebude ≈•a to st√°≈• skoro ≈æiadnu n√°mahu. Proste vo svojej aplik√°ci√≠ nastav√≠≈° adresu ERC20 tokenu, a bum, tvoja aplik√°cia pracuje s ƒèal≈°√≠m tokenom.
This means if you build an application that is capable of interacting with one ERC20 token, it's also capable of interacting with any ERC20 token. That way more tokens can easily be added to your app in the future without needing to be custom coded. You could simply plug in the new token contract address, and boom, your app has another token it can use.

Jedn√Ωm tak√Ωm pr√≠kladom s√∫ exchange. Keƒè sa exchange rozhodne prida≈• nov√Ω ERC20 token, je to pre nich jednoduch√©. Staƒç√≠ im prida≈• do ich zoznamu adresu smart kontraktu reprezentuj√∫ci dan√Ω token. U≈æ√≠vatelia m√¥≈æu potom prostredn√≠ctom rovnak√©ho kontraktu posla≈• tieto tokeny na adresu exchange. Naopak, keƒè sa u≈æ√≠vateƒæ rozhodne tokeny si z exchange vytiahnu≈•, exchange prostredn√≠ctvom tohoto kontraktu po≈°le tokeny tam, kam si to u≈æ√≠vateƒæ ≈æel√°.
One example of this would be an exchange. When an exchange adds a new ERC20 token, really it just needs to add another smart contract it talks to. Users can tell that contract to send tokens to the exchange's wallet address, and the exchange can tell the contract to send the tokens back out to users when they request a withdraw.

Exchange implementuje logiku prenosu tokenov len raz. Keƒè sa potom rozhodne podporova≈• nov√Ω ERC20 token, je to len z√°le≈æitos≈• pridania novej smart kontrakt adresy do ich datab√°zy.  
The exchange only needs to implement this transfer logic once, then when it wants to add a new ERC20 token, it's simply a matter of adding the new contract address to its database.

### ƒéal≈°ie token ≈°tandardy
### Other token standards

ERC20 tokeny su fakt super, preto≈æe tokeny sa spr√°vaj√∫ ako meny. Av≈°ak tie by neboli veƒæmi u≈æitoƒçn√© pre reprezent√°ciu zombiekov v na≈°ej hre.
ERC20 tokens are really cool for tokens that act like currencies. But they're not particularly useful for representing zombies in our zombie game.

Za prv√©, zombie nie s√∫ deliteln√Ω ako meny. S√≠ce niekomu m√¥≈æe≈° posla≈• 0.237 ETH, no odoslanie 237 tis√≠cin tvojho zombie celkom ned√°va zmysel. 
For one, zombies aren't divisible like currencies ‚Äî¬†I can send you 0.237 ETH, but transfering you 0.237 of a zombie doesn't really make sense.

Za druhe, nie v≈°etci zombie s√∫ si rovn√≠. Tvoj Level 2 zombie "**Steve**" absol√∫tne nie je rovn√Ω m√¥jmu Level 732 zombie "**H4XF13LD MORRIS üíØüíØüòéüíØüíØ**". (Nie, ani tro≈°ku, *Steve*)
Secondly, all zombies are not created equal. Your Level 2 zombie "**Steve**" is totally not equal to my Level 732 zombie "**H4XF13LD MORRIS üíØüíØüòéüíØüíØ**". (Not even close, *Steve*).

Existuje in√Ω token ≈°tandard, ktor√Ω je oveƒæa vhodnej≈°√≠ pre krypto zberatelsk√© predmety (crypto-collectibles) ako CryptoZombies. S√∫ to **_ERC721 tokeny_**.
There's another token standard that's a much better fit for crypto-collectibles like CryptoZombies ‚Äî¬†and they're called **_ERC721 tokens._**

**_ERC721 tokeny_** **NIE S√ö** zameniteƒæn√©, preto≈æe ka≈æd√Ω jeden z nich je pova≈æovan√Ω za unik√°tny a ƒèalej nedeliteƒæn√Ω. Je mo≈æn√© ich obchodova≈• v celkoch, ka≈æd√Ω ma unik√°tne ID. Tak≈æe su perfektn√Ωm kandid√°tom na to, ako spravi≈• na≈°ich zombie obchodovateƒæn√Ωch.
**_ERC721 tokens_** are **not** interchangeable since each one is assumed to be unique, and are not divisible. You can only trade them in whole units, and each one has a unique ID. So these are a perfect fit for making our zombies tradeable.

> Uvedom si ≈æe pou≈æ√≠vanie ≈°tandardu ako ERC721 m√° v√Ωhodu v tom ≈æe v r√°mci na≈°eho kontraktu nemus√≠me implementova≈• logiku aukci√≠ a escrow, ktor√° by urƒçovala ako hr√°ƒçi m√¥≈æu obchodova≈• a pred√°va≈• svojich zombie. Namiesto toho, niekto in√Ω m√¥≈æe vytvori≈• platformu na obchodovanie s ERC721 akt√≠vami. Potom pokiaƒæ s√∫ na≈°i zomb√≠ci v s√∫lade s ERC721, na≈°i zomb√≠ci budu plne kompatibiln√Ω s takou obchodovacou platformou. Tak≈æe toto je jasn√° v√Ωhoda dodr≈æiava≈• token ≈°tandardy, namiesto vym√Ω≈°lania vlastnej obchodovacej logiky.
> Note that using a standard like ERC721 has the benefit that we don't have to implement the auction or escrow logic within our contract that determines how players can trade / sell our zombies. If we conform to the spec, someone else could build an exchange platform for crypto-tradable ERC721 assets, and our ERC721 zombies would be usable on that platform. So there are clear benefits to using a token standard instead of rolling your own trading logic.

## Vysk√∫≈°aj si to s√°m
## Putting it to the Test

V ƒèal≈°ej kapitole sa ideme ponori≈• do implement√°cie ERC721. Ale pred t√Ωm, poƒème si pripravi≈• s√∫bor s nov√Ωm kontraktom.
We're going to dive into the ERC721 implementation in the next chapter. But first, let's set up our file structure for this lesson.

V≈°etku logiku stojen√∫ s ERC721 budeme ma≈• v kontrakte n√°zvom `ZombieOwnership`.
We're going to store all the ERC721 logic in a contract called `ZombieOwnership`.

1. Na zaƒçiatku s√∫boru deklaruj verziu `pragma` (pozri si s√∫bory z predo≈°l√Ωch lekci√≠ pre zopakovanie syntaxe).
1. Declare our `pragma` version at the top of the file (check previous lessons' files for the syntax).

2. ƒéalej sprav `import` s√∫boru `zombieattack.sol`.
2. This file should `import` from `zombieattack.sol`.

3. Deklaruj nov√Ω kontrakt, `ZombieOwnership`, ktor√Ω ded√≠ od  `ZombieAttack`. Telo kontraktu ponechaj zatiaƒæ pr√°zdne.
3. Declare a new contract, `ZombieOwnership`, that inherits from `ZombieAttack`. Leave the body of the contract empty for now.
